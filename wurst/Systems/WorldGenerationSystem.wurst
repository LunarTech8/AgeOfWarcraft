/*-------------------------------------------------------------
// Version number:
1.0.0

// Description:
Handles world map generation like terrain deformation and unit placement.

// Changelog:
- 1.0.0:
Initial version.
-------------------------------------------------------------*/
package WorldGenerationSystem
import TerrainUtils
import Interpolation
import Array2D
import ConstantData
import UtilityFunctions
import Entity
import ResourceSystem
import LoadStatusSystem
import ComputationControl
import Destructable_Spruce
import NoiseFunctions
import SaveLoadData
import UnitTest


// --------------------
// Data code
// --------------------

// General:
let TILES_X = 104
let TILES_Y = 104
let ORIGIN_VEC = vec2(-6656., -7168.)  // Left, bottom point from which the terrain generation starts towards right, top point
let USER_PLAYER = Player(0)
let WORLD_DATA_LOAD = false
let WORLD_DATA_SAVE = true
let WORLD_DATA_FILE_NAME = "WorldData.pld"  // In folder ..\Documents\Warcraft III\CustomMapData
let WORLD_DATA_PART_LENGTHS = [0, 4, 5]  // Indices where one data value ends and the next one starts
let NUMBER_BASE_CHUNK_SIZE = 7
let CHAR_BASE_CHUNK_SIZE = 4
let CHAR_BASE_SIZE = 62
let CHAR_BASE_POLYNOM_FACTORS = [1, 62, 62 * 62, 62 * 62 * 62]

// Terrain:
let TERRAIN_HEIGHT_INIT = 0.
let TERRAIN_HEIGHT_MIN = -64.  // Min HEIGHT_DEEP_WATER_MIN
let TERRAIN_HEIGHT_MAX = HEIGHT_LAND_MIN + 764.  // Max HEIGHT_LAND_MAX

// Plants:
let NATURE_PLAYER = Player(PLAYER_NEUTRAL_PASSIVE)

enum PlantBiomeType
	BARRENS
	MEADOW
	SHRUBLAND
	WOODS
	FOREST

function getPlantBiomeType(real plantNoiseValue) returns PlantBiomeType
	if plantNoiseValue >= 0.8
		return PlantBiomeType.FOREST
	else if plantNoiseValue >= 0.6
		return PlantBiomeType.WOODS
	else if plantNoiseValue >= 0.4
		return PlantBiomeType.SHRUBLAND
	else if plantNoiseValue >= 0.2
		return PlantBiomeType.MEADOW
	else
		return PlantBiomeType.BARRENS


// --------------------
// Functional code
// --------------------

Array2DReal heightMap = new Array2DReal(TILES_X, TILES_Y)
Array2DInt plantMap = new Array2DInt(TILES_X, TILES_Y)

function convertNumbersToChars(ChunkedString numberChunks) returns ChunkedString
	// Transform source chunks into required size if needed:
	var numberChunksSized = numberChunks
	if numberChunks.getChunkSize() != NUMBER_BASE_CHUNK_SIZE
		numberChunksSized = new ChunkedString(numberChunks, NUMBER_BASE_CHUNK_SIZE)
	// Create target chunks by converting source chunks:
	let charChunks = new ChunkedString()
	while numberChunksSized.hasChunk()
		var value = numberChunksSized.readChunk().toInt()
		var chars = ""
		while value > 0
			chars += (value mod CHAR_BASE_SIZE).toCharsetString()
			value = value div CHAR_BASE_SIZE
		while chars.length() < CHAR_BASE_CHUNK_SIZE
			chars += "0"
		charChunks.append(chars)
	if numberChunksSized != numberChunks
		destroy numberChunksSized
	return charChunks

function convertCharsToNumbers(ChunkedString charChunks) returns ChunkedString
	// Transform chunks into required size if needed:
	var charChunksSized = charChunks
	if charChunks.getChunkSize() != CHAR_BASE_CHUNK_SIZE
		charChunksSized = new ChunkedString(charChunks, CHAR_BASE_CHUNK_SIZE)
	// Create target chunks by converting source chunks:
	let numberChunks = new ChunkedString()
	while charChunksSized.hasChunk()
		let charChunk = charChunksSized.readChunk()
		var value = 0
		for i = 0 to (charChunk.length() - 1)
			value += charChunk.substring(i, i + 1).toCharsetInt() * CHAR_BASE_POLYNOM_FACTORS[i]
		var numbers = value.toString()
		while numbers.length() < NUMBER_BASE_CHUNK_SIZE
			numbers = "0" + numbers
		numberChunks.append(numbers)
	if charChunksSized != charChunks
		destroy charChunksSized
	return numberChunks

function encodeWorldData() returns ChunkedString
	let maxHeightValueEncoded = (10).pow(WORLD_DATA_PART_LENGTHS[1] - WORLD_DATA_PART_LENGTHS[0])
	let data = new ChunkedString()
	newInitSubStatus("Test9 " + computationCost.toString())  // DEBUG:
	for	x = 0 to TILES_X - 1
		setInitStepStatus(x + 1, TILES_X)  // DEBUG:
		for	y = 0 to TILES_Y - 1
			let heightValueEncoded = (((heightMap.get(x, y) - TERRAIN_HEIGHT_MIN) * 10.).round() + maxHeightValueEncoded).toString().substring(1)
			let plantValueEncoded = plantMap.get(x, y).toString()
			data.append(heightValueEncoded + plantValueEncoded)
	let convertedData = convertNumbersToChars(data)
	destroy data
	return convertedData

function decodeWorldData(ChunkedString data)
	let dataPartLength = WORLD_DATA_PART_LENGTHS[WORLD_DATA_PART_LENGTHS.length - 1]
	let convertedData = convertCharsToNumbers(data)
	newInitSubStatus("Test10 " + computationCost.toString())  // DEBUG:
	for	x = 0 to TILES_X - 1
		setInitStepStatus(x + 1, TILES_X)  // DEBUG:
		for	y = 0 to TILES_Y - 1
			let dataPart = convertedData.getUnsafeSubString((y + TILES_Y * x) * dataPartLength, (y + TILES_Y * x + 1) * dataPartLength)
			var i = 0
			let heightValueDecoded = dataPart.substring(WORLD_DATA_PART_LENGTHS[i], WORLD_DATA_PART_LENGTHS[i] + WORLD_DATA_PART_LENGTHS[i + 1]).toReal() * 0.1 + TERRAIN_HEIGHT_MIN
			i += 1
			let plantValueDecoded = dataPart.substring(WORLD_DATA_PART_LENGTHS[i], WORLD_DATA_PART_LENGTHS[i] + WORLD_DATA_PART_LENGTHS[i + 1]).toInt()
			heightMap.set(x, y, heightValueDecoded)
			plantMap.set(x, y, plantValueDecoded)
	destroy convertedData

function generateWorldData()
	// Create height map:
	newInitStatus("Height data creation")
	var noiseMap = generatePerlinNoise(TILES_X, TILES_Y, 7, 0.6, "Cosine")
	newInitSubStatus("Calculate height data")
	newInitSubStatus("Test5 " + computationCost.toString())  // DEBUG:
	for	x = 0 to TILES_X - 1
		setInitStepStatus(x + 1, TILES_X)
		for	y = 0 to TILES_Y - 1
			heightMap.set(x, y, linear(TERRAIN_HEIGHT_MIN, TERRAIN_HEIGHT_MAX, noiseMap.get(x, y)))
			computationCost += 0.069
		checkForComputationBreak()
	forceComputationBreak()
	destroy noiseMap
	forceComputationBreak()
	// Create plant map:
	newInitStatus("Plant data creation")
	noiseMap = generatePerlinNoise(TILES_X, TILES_Y, 5, 0.6, "Cosine")
	newInitSubStatus("Calculate plant data")
	newInitSubStatus("Test6 " + computationCost.toString())  // DEBUG:
	for	x = 0 to TILES_X - 1
		setInitStepStatus(x + 1, TILES_X)
		for	y = 0 to TILES_Y - 1
			plantMap.set(x, y, getPlantBiomeType(noiseMap.get(x, y)) castTo int)
			computationCost += 0.067
		checkForComputationBreak()
	forceComputationBreak()
	destroy noiseMap

public function createWorldData()
	// Load or generate world data:
	if WORLD_DATA_LOAD  // TEST:
		newInitStatus("World data creation")
		newInitStatus("World data creation")  // FIXME: two calls required to fit with generation task -> mabye split decoding for height and plant
		USER_PLAYER.loadData(WORLD_DATA_FILE_NAME) (status, data) ->
			if status == SUCCESS
				decodeWorldData(data)
			else
				Log.error(status.toString())
			destroy data
	else
		generateWorldData()
	// Save world data if requested:
	if WORLD_DATA_SAVE  // TEST: probably to big world data (271 chunks), but only 64 allowed per file -> mabye better encoding helps or data has to be saved in multiple files
		let encodedData = encodeWorldData()
		USER_PLAYER.saveData(WORLD_DATA_FILE_NAME, encodedData)
		destroy encodedData

public function createTerrain()
	newInitStatus("Terrain creation")
	// Adjust the height for each tile:
	newInitSubStatus("Adjust terrain heights")
	newInitSubStatus("Test7 " + computationCost.toString())  // DEBUG:
	for	x = 0 to TILES_X - 1
		setInitStepStatus(x + 1, TILES_X)
		for	y = 0 to TILES_Y - 1
			let z = heightMap.get(x, y)
			let pos = ORIGIN_VEC.add(x * TILE_DISTANCE, y * TILE_DISTANCE)
			pos.addTerrainHeight(z - TERRAIN_HEIGHT_INIT)  // Terrain has to have water on it before hand for it to show up
			let tile = pos.getTile()
			// Assert that pathing is set to deep water beforehand
			if z >= HEIGHT_LAND_MIN
				tile.setPathing(PATHING_TYPE_FLOATABILITY, false)
				tile.setPathing(PATHING_TYPE_WALKABILITY, true)
				tile.setPathing(PATHING_TYPE_BUILDABILITY, true)
			else if z >= HEIGHT_SHALLOW_WATER_MIN
				tile.setPathing(PATHING_TYPE_WALKABILITY, true)
				tile.setPathing(PATHING_TYPE_BUILDABILITY, false)
			computationCost += 0.821
		checkForComputationBreak()

public function createPlants()
	newInitStatus("Plants creation")
	// Have 1 or 0 tree per tile:
	newInitSubStatus("Add trees")
	newInitSubStatus("Test8 " + computationCost.toString())  // DEBUG:
	for	x = 0 to TILES_X - 1
		setInitStepStatus(x + 1, TILES_X)
		for	y = 0 to TILES_Y - 1
			let plantBiome = plantMap.get(x, y) castTo PlantBiomeType
			if plantBiome == FOREST
				let pos = ORIGIN_VEC + vec2(x + GetRandomReal(-0.5, 0.5), y + GetRandomReal(-0.5, 0.5)) * TILE_DISTANCE
				// createUnit(NATURE_PLAYER, UnitIdsCustom.Trees.beech.getUnitTypeId(), pos, getRandomAngle())  // DEBUG:
				// entity(null, createDestructable(DestructableIdsCustom.Trees.spruce, pos, getRandomAngle(), GetRandomReal(DestructableData_Spruce.minScale, DestructableData_Spruce.maxScale), getRandomVariation(DestructableData_Spruce.variations))).tryAddResouce()
				entity(null, createDestructable(DestructableIdsCustom.Trees.spruce, pos, getRandomAngle(), DestructableData_Spruce.maxScale, getRandomVariation(DestructableData_Spruce.variations))).tryAddResouce()
			else if plantBiome == WOODS
				let pos = ORIGIN_VEC + vec2(x + GetRandomReal(-0.5, 0.5), y + GetRandomReal(-0.5, 0.5)) * TILE_DISTANCE
				entity(null, createDestructable(DestructableIdsCustom.Trees.spruce, pos, getRandomAngle(), DestructableData_Spruce.minScale, getRandomVariation(DestructableData_Spruce.variations))).tryAddResouce()
			computationCost += 0.206
		checkForComputationBreak()


// --------------------
// Test code
// --------------------

// @Test public function testWorldGenerationSystem_EncodeAndDecode()
// 	testWorldGenerationSystem_EncodeAndDecode(false)
public function testWorldGenerationSystem_EncodeAndDecode(bool isInGameTest)
	let REAL_COMPARE_DELTA = 0.01
	let MAX_HEIGHT_VALUE_ENCODED = (10).pow(WORLD_DATA_PART_LENGTHS[1] - WORLD_DATA_PART_LENGTHS[0])
	let MAX_PLANT_VALUE_ENCODED = (PlantBiomeType.FOREST castTo int) + 1
	let DATA_PART_LENGTH = WORLD_DATA_PART_LENGTHS[WORLD_DATA_PART_LENGTHS.length - 1]
	let testName = setTestName("testWorldGenerationSystem_EncodeAndDecode", isInGameTest)
	// Set data:
	for	x = 0 to TILES_X - 1
		for	y = 0 to TILES_Y - 1
			heightMap.set(x, y, TERRAIN_HEIGHT_MIN)
			plantMap.set(x, y, 0)
			heightMap.get(x, y).assertEquals(testName, TERRAIN_HEIGHT_MIN, REAL_COMPARE_DELTA)
			plantMap.get(x, y).assertEquals(testName, 0)
	// Encode and check data:
	var encodedData = encodeWorldData()
	encodedData.length().assertEquals(testName, TILES_X * TILES_Y * DATA_PART_LENGTH)
	encodedData.getChunkCount().assertEquals(testName, ((TILES_X * TILES_Y * DATA_PART_LENGTH) / DEFAULT_CHUNK_SIZE).ceil())
	encodedData.getUnsafeSubString(0 * DATA_PART_LENGTH, (0 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0000" + "0")
	encodedData.getUnsafeSubString(1 * DATA_PART_LENGTH, (1 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0000" + "0")
	encodedData.getUnsafeSubString(9 * DATA_PART_LENGTH, (9 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0000" + "0")
	encodedData.getUnsafeSubString(10042 * DATA_PART_LENGTH, (10042 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0000" + "0")
	// Set data:
	for	x = 0 to TILES_X - 1
		for	y = 0 to TILES_Y - 1
			heightMap.set(x, y, ((y + TILES_Y * x) mod MAX_HEIGHT_VALUE_ENCODED) * 0.1 + TERRAIN_HEIGHT_MIN)
			plantMap.set(x, y, (y + TILES_Y * x) mod MAX_PLANT_VALUE_ENCODED)
	heightMap.get(0, 0).assertEquals(testName, 0.0 + TERRAIN_HEIGHT_MIN, REAL_COMPARE_DELTA)
	heightMap.get(0, 1).assertEquals(testName, 0.1 + TERRAIN_HEIGHT_MIN, REAL_COMPARE_DELTA)
	heightMap.get(0, 2).assertEquals(testName, 0.2 + TERRAIN_HEIGHT_MIN, REAL_COMPARE_DELTA)
	heightMap.get(0, 3).assertEquals(testName, 0.3 + TERRAIN_HEIGHT_MIN, REAL_COMPARE_DELTA)
	destroy encodedData
	// Encode and check data:
	encodedData = encodeWorldData()
	encodedData.getUnsafeSubString(0 * DATA_PART_LENGTH, (0 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0000" + "0")
	encodedData.getUnsafeSubString(1 * DATA_PART_LENGTH, (1 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0001" + "1")
	encodedData.getUnsafeSubString(2 * DATA_PART_LENGTH, (2 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0002" + "2")
	encodedData.getUnsafeSubString(3 * DATA_PART_LENGTH, (3 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0003" + "3")
	encodedData.getUnsafeSubString(9 * DATA_PART_LENGTH, (9 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0009" + "4")
	encodedData.getUnsafeSubString(10042 * DATA_PART_LENGTH, (10042 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0042" + "2")
	// Clear data:
	for	x = 0 to TILES_X - 1
		for	y = 0 to TILES_Y - 1
			heightMap.set(x, y, 0.)
			plantMap.set(x, y, 0)
	// Decode and check data:
	decodeWorldData(encodedData)
	for	x = 0 to TILES_X - 1
		for	y = 0 to TILES_Y - 1
			heightMap.get(x, y).assertEquals(testName, ((y + TILES_Y * x) mod MAX_HEIGHT_VALUE_ENCODED) * 0.1 + TERRAIN_HEIGHT_MIN, REAL_COMPARE_DELTA)
			plantMap.get(x, y).assertEquals(testName, (y + TILES_Y * x) mod MAX_PLANT_VALUE_ENCODED)
	destroy encodedData

@Test public function testWorldGenerationSystem_Convert()
	testWorldGenerationSystem_Convert(false)
public function testWorldGenerationSystem_Convert(bool isInGameTest)
	let testName = setTestName("testWorldGenerationSystem_Convert", isInGameTest)
	string stringA
	int intA
	// Set number data:
	var numberChunks = new ChunkedString(NUMBER_BASE_CHUNK_SIZE)
	numberChunks.append("1230597")
	// Convert and check data:
	var charChunks = convertNumbersToChars(numberChunks)
	charChunks.length().assertEquals(testName, (numberChunks.length() / NUMBER_BASE_CHUNK_SIZE).ceil() * CHAR_BASE_CHUNK_SIZE)
	stringA = (21).toCharsetString()
	stringA += (8).toCharsetString()
	stringA += (10).toCharsetString()
	stringA += (5).toCharsetString()
	charChunks.getUnsafeSubString(0, CHAR_BASE_CHUNK_SIZE).assertEquals(testName, stringA)
	destroy numberChunks
	// Reconvert and check data:
	numberChunks = convertCharsToNumbers(charChunks)
	numberChunks.length().assertEquals(testName, (charChunks.length() / CHAR_BASE_CHUNK_SIZE).ceil() * NUMBER_BASE_CHUNK_SIZE)
	numberChunks.getUnsafeSubString(0, NUMBER_BASE_CHUNK_SIZE).assertEquals(testName, "1230597")
	destroy charChunks
	destroy numberChunks
	// Set char data:
	charChunks = new ChunkedString(CHAR_BASE_CHUNK_SIZE)
	charChunks.append("cZ0a")
	// Convert and check data:
	numberChunks = convertCharsToNumbers(charChunks)
	numberChunks.length().assertEquals(testName, (charChunks.length() / CHAR_BASE_CHUNK_SIZE).ceil() * NUMBER_BASE_CHUNK_SIZE)
	intA = ("c").toCharsetInt() * CHAR_BASE_POLYNOM_FACTORS[0]
	intA += ("Z").toCharsetInt() * CHAR_BASE_POLYNOM_FACTORS[1]
	intA += ("0").toCharsetInt() * CHAR_BASE_POLYNOM_FACTORS[2]
	intA += ("a").toCharsetInt() * CHAR_BASE_POLYNOM_FACTORS[3]
	stringA = intA.toString()
	numberChunks.getUnsafeSubString(0, NUMBER_BASE_CHUNK_SIZE).assertEquals(testName, stringA)
	destroy charChunks
	// Reconvert and check data:
	charChunks = convertNumbersToChars(numberChunks)
	charChunks.length().assertEquals(testName, (numberChunks.length() / NUMBER_BASE_CHUNK_SIZE).ceil() * CHAR_BASE_CHUNK_SIZE)
	charChunks.getUnsafeSubString(0, CHAR_BASE_CHUNK_SIZE).assertEquals(testName, "cZ0a")
	destroy numberChunks
	destroy charChunks
	// Set number data:
	numberChunks = new ChunkedString()
	numberChunks.append("1230597" + "144")
	// Convert and check data:
	charChunks = convertNumbersToChars(numberChunks)
	charChunks.length().assertEquals(testName, (numberChunks.length() / NUMBER_BASE_CHUNK_SIZE).ceil() * CHAR_BASE_CHUNK_SIZE)
	stringA = (21).toCharsetString()
	stringA += (8).toCharsetString()
	stringA += (10).toCharsetString()
	stringA += (5).toCharsetString()
	charChunks.getUnsafeSubString(0, CHAR_BASE_CHUNK_SIZE).assertEquals(testName, stringA)
	stringA = (20).toCharsetString()
	stringA += (2).toCharsetString()
	while stringA.length() < CHAR_BASE_CHUNK_SIZE
		stringA += "0"
	charChunks.getUnsafeSubString(CHAR_BASE_CHUNK_SIZE, CHAR_BASE_CHUNK_SIZE * 2).assertEquals(testName, stringA)
	destroy numberChunks
	// Reconvert and check data:
	numberChunks = convertCharsToNumbers(charChunks)
	numberChunks.length().assertEquals(testName, (charChunks.length() / CHAR_BASE_CHUNK_SIZE).ceil() * NUMBER_BASE_CHUNK_SIZE)
	numberChunks.getUnsafeSubString(0, NUMBER_BASE_CHUNK_SIZE).assertEquals(testName, "1230597")
	numberChunks.getUnsafeSubString(NUMBER_BASE_CHUNK_SIZE, NUMBER_BASE_CHUNK_SIZE * 2).assertEquals(testName, "0000144")
	destroy charChunks
	destroy numberChunks
	// Set char data:
	charChunks = new ChunkedString()
	charChunks.append("cZ0a" + "8J")
	// Convert and check data:
	numberChunks = convertCharsToNumbers(charChunks)
	numberChunks.length().assertEquals(testName, (charChunks.length() / CHAR_BASE_CHUNK_SIZE).ceil() * NUMBER_BASE_CHUNK_SIZE)
	intA = ("c").toCharsetInt() * CHAR_BASE_POLYNOM_FACTORS[0]
	intA += ("Z").toCharsetInt() * CHAR_BASE_POLYNOM_FACTORS[1]
	intA += ("0").toCharsetInt() * CHAR_BASE_POLYNOM_FACTORS[2]
	intA += ("a").toCharsetInt() * CHAR_BASE_POLYNOM_FACTORS[3]
	stringA = intA.toString()
	numberChunks.getUnsafeSubString(0, NUMBER_BASE_CHUNK_SIZE).assertEquals(testName, stringA)
	intA = ("8").toCharsetInt() * CHAR_BASE_POLYNOM_FACTORS[0]
	intA += ("J").toCharsetInt() * CHAR_BASE_POLYNOM_FACTORS[1]
	stringA = intA.toString()
	while stringA.length() < NUMBER_BASE_CHUNK_SIZE
		stringA = "0" + stringA
	numberChunks.getUnsafeSubString(NUMBER_BASE_CHUNK_SIZE, NUMBER_BASE_CHUNK_SIZE * 2).assertEquals(testName, stringA)
	destroy charChunks
	// Reconvert and check data:
	charChunks = convertNumbersToChars(numberChunks)
	charChunks.length().assertEquals(testName, (numberChunks.length() / NUMBER_BASE_CHUNK_SIZE).ceil() * CHAR_BASE_CHUNK_SIZE)
	charChunks.getUnsafeSubString(0, CHAR_BASE_CHUNK_SIZE).assertEquals(testName, "cZ0a")
	charChunks.getUnsafeSubString(CHAR_BASE_CHUNK_SIZE, CHAR_BASE_CHUNK_SIZE * 2).assertEquals(testName, "8J00")
	destroy numberChunks
	destroy charChunks