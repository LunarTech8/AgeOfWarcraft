/*-------------------------------------------------------------
// Version number:
1.0.0

// Description:
Handles workplace buildings that produce educts out of products with the help of workers.

// Changelog:
- 1.0.0:
Initial version.
-------------------------------------------------------------*/
package WorkshopSystem
import ConstantData
import UnitMap
import LinkedList
import UnitTest
import Stock
import UtilityFunctions
import MultiboardPrioritySystem
import UnitIndexer
import ClosureTimers
import Icons
import RegisterEvents
import StorageSystem
import Orders
import ErrorHandling
import WorkplaceSystem


// --------------------
// Data code
// --------------------

public let MAX_STORABLE_EDUCTS = 5
public let MAX_STORABLE_PRODUCTS = 3

let PRODUCTION_ADJUSTMENT_RATE = 0.1
let PRODUCTION_PROGRESS_ICON_PATH = Icons.bTNEngineeringUpgrade
let PRODUCTION_TIME_LEFT_ICON_PATH = Icons.bTNStatUp
let WORKERS_ICON_PATH = Icons.bTNBash

/** Returns the production progress that the given worker type does per second in the given workshop type. */
function getUnitWorkPower(int workshopUnitId, int workerUnitId) returns real
	switch workerUnitId
		case UnitIdsCustom.AoW.peasant
			switch workshopUnitId
				case UnitIdsCustom.AoW.lumberMill
					return 1.
				case UnitIdsCustom.AoW.blacksmith
					return 1.
	return 0.

/** Returns the required production progress in seconds of the given workshop type. */
function getRequiredWorkPower(int workshopUnitId, int productionVariant) returns real
	switch workshopUnitId
		case UnitIdsCustom.AoW.lumberMill
			switch productionVariant
				case 1
					return 15.
				case 2
					return 10.
		case UnitIdsCustom.AoW.blacksmith
			switch productionVariant
				case 1
					return 20.
	return 0.

/** Returns educts for given workshop type and production variant. */
function getWorkshopEducts(int workshopUnitId, int productionVariant) returns LinkedList<ware>
	let wares = new LinkedList<ware>()
	switch workshopUnitId
		case UnitIdsCustom.AoW.lumberMill
			switch productionVariant
				case 1
					wares.add(ware(WareType.WOOD, 3))
				case 2
					wares.add(ware(WareType.WOOD, 1))
		case UnitIdsCustom.AoW.blacksmith
			switch productionVariant
				case 1
					wares.add(ware(WareType.IRON_ORE, 1))
					wares.add(ware(WareType.COAL, 1))
	return wares

/** Returns products for given workshop type and production variant. */
function getWorkshopProducts(int workshopUnitId, int productionVariant) returns LinkedList<ware>
	let wares = new LinkedList<ware>()
	switch workshopUnitId
		case UnitIdsCustom.AoW.lumberMill
			switch productionVariant
				case 1
					wares.add(ware(WareType.WOODEN_BOARDS, 2))
				case 2
					wares.add(ware(WareType.WOODEN_STICKS, 1))
		case UnitIdsCustom.AoW.blacksmith
			switch productionVariant
				case 1
					wares.add(ware(WareType.METAL, 1))
	return wares


// --------------------
// Functional code
// --------------------

let WORKSHOP_MAP = new IterableUnitHashMap<Workshop>(null)

public class Workshop extends Workplace
	private Stock stock
	private int productionVariant
	private real workProgressCurrent
	private real workProgressFinished
	private real workPower

	construct(unit workshop)
		super(workshop)
		stock = new Stock(new LinkedList<ware>())
		productionVariant = 1
		workProgressCurrent = 0.
		workProgressFinished = getRequiredWorkPower(workshop.getUnitId(), productionVariant)
		workPower = 0.

	ondestroy
		destroy stock

	private function startProduction() returns bool
		// Check if there are enough educts:
		let educts = getEducts()
		if stock.hasWares(educts)
			// Check if there is enough free space for the products:
			let products = getProducts()
			for iWare in products
				if stock.getWareCount(iWare.wareType) > iWare.count * (MAX_STORABLE_PRODUCTS - 1)
					// Too many products:
					destroy products
					return false
			destroy products
			// Start production:
			stock.removeWares(educts)
			destroy educts
			return true
		else
			// Not enough educts:
			destroy educts
			return false

	private function cancelProduction()
		// Check if a production is in progress:
		if workProgressCurrent > 0.
			// Reset work progress:
			workProgressCurrent = 0.
			// Regain educts:
			let educts = getEducts()
			stock.addWares(educts)
			destroy educts

	function getStock() returns Stock
		return stock

	function getStoredEductsCount() returns int
		var amount = MAX_WARE_COUNT
		let educts = getEducts()
		for iWare in educts
			amount = min(amount, stock.getWareCount(iWare.wareType) div iWare.count)
		destroy educts
		return amount

	function getStoredProductsCount() returns int
		var amount = MAX_WARE_COUNT
		let products = getProducts()
		for iWare in products
			amount = min(amount, stock.getWareCount(iWare.wareType) div iWare.count)
		destroy products
		return amount

	function getProducts() returns LinkedList<ware>
		return getWorkshopProducts(user.getUnitId(), productionVariant)

	function getEducts() returns LinkedList<ware>
		return getWorkshopEducts(user.getUnitId(), productionVariant)

	function getWorkProgressPercentage() returns real
		return 100. * workProgressCurrent / workProgressFinished

	function getWorkProgressLeft() returns real
		return workProgressFinished - workProgressCurrent

	function getWorkPower() returns real
		return workPower

	function changeProduct()
		if getRequiredWorkPower(user.getUnitId(), productionVariant + 1) > 0.
			cancelProduction()
			productionVariant = productionVariant + 1
		else if productionVariant != 1
			cancelProduction()
			productionVariant = 1
		workProgressFinished = getRequiredWorkPower(user.getUnitId(), productionVariant)

	function adjustProgress() returns bool
		if workPower > 0.
			// Check if a new production has to be startet:
			if workProgressCurrent <= 0. and startProduction() == false
				return false
			// Adjust work progress:
			workProgressCurrent += workPower * PRODUCTION_ADJUSTMENT_RATE
			if workProgressCurrent >= workProgressFinished
				// Finish production:
				let products = getProducts()
				stock.addWares(products)
				destroy products
				// Directly start with next production if possible:
				if startProduction()
					workProgressCurrent -= workProgressFinished
				else
					workProgressCurrent = 0.
				return true
		return false

	function enterBuilding(unit worker)
		if workers.contains(worker) == false
			error("Worker does not belong to this workshop")
		workPower += getUnitWorkPower(user.getUnitId(), worker.getUnitId())

	function leaveBuilding(unit worker)
		if workers.contains(worker) == false
			error("Worker does not belong to this workshop")
		workPower -= getUnitWorkPower(user.getUnitId(), worker.getUnitId())

	/** Transfers as many educts as possible from source storage to this workshop.
	Afterwards transfers as many products as possible from this workshop to source storage. */
	override function transferWares(Storage source, bool takeProducts)
		// Look for educts in source:
		let educts = getEducts()
		for iWare in educts
			let wareCount = min(iWare.count * MAX_STORABLE_EDUCTS - stock.getWareCount(iWare.wareType), source.getWareCount(iWare.wareType))
			if wareCount > 0
				// Transfer ware:
				source.removeWare(ware(iWare.wareType, wareCount))
				stock.addWare(ware(iWare.wareType, wareCount))
		destroy educts
		// Look for products in workshop:
		if takeProducts
			let products = getProducts()
			for iWare in products
				let wareCount = min(stock.getWareCount(iWare.wareType), source.getFreeCapacity())
				if wareCount > 0
					// Transfer ware:
					stock.removeWare(ware(iWare.wareType, wareCount))
					source.addWare(ware(iWare.wareType, wareCount))
			destroy products


function unit.addWorkshop()
	if WORKSHOP_MAP.has(this) == false and getRequiredWorkPower(this.getUnitId(), 1) > 0.
		WORKSHOP_MAP.put(this, new Workshop(this))

function unit.removeWorkshop()
	let workshop = WORKSHOP_MAP.tryRemove(this)
	if workshop != null
		destroy workshop

/** Returns the workshop of given unit. */
public function unit.getWorkshop() returns Workshop
	return WORKSHOP_MAP.tryGet(this)

/** Creates and returns a workshop building with given values. */
public function createWorkshopBuilding(player owner, int unitId, vec2 pos, angle facing) returns unit
	let building = createUnit(owner, unitId, pos, facing)
	building.addWorkshop()
	if WORKSHOP_MAP.has(building) == FALSE
		error("Could not create " + building.getName() + " as workshop building")
	return building

/** Sets system relevant infos for given object in target multiboard. */
public function multiboard.setObjectInfoMultiboard(Workshop ws) returns bool
	this.addMultiboardLine("Workshop: " + ws.user.getName(), HEADLINE_ICON_PATH)
	this.addMultiboardLine("Production progress: " + ws.getWorkProgressPercentage().toInt().toString() + "%", PRODUCTION_PROGRESS_ICON_PATH)
	let workPower = ws.getWorkPower()
	if workPower > 0.
		this.addMultiboardLine("Production time left: " + (ws.getWorkProgressLeft() / workPower).toInt().toString() + "s", PRODUCTION_TIME_LEFT_ICON_PATH)
		this.addMultiboardLine("Workers: " + ws.getWorkerCount().toString() + "/" + ws.getMaxWorkerSlots().toString(), WORKERS_ICON_PATH)
	this.addMultiboardLine("Educts (" + ws.getStoredEductsCount().toString() + "/" + MAX_STORABLE_EDUCTS.toString() + "):", SUB_HEADLINE_ICON_PATH)
	let educts = ws.getEducts()
	for ware in educts
		this.addMultiboardLine(ware.count.toString() + " " + ware.toString(true), ware.getIconPath())
	destroy educts
	this.addMultiboardLine("Products (" + ws.getStoredProductsCount().toString() + "/" + MAX_STORABLE_PRODUCTS.toString() + ")", SUB_HEADLINE_ICON_PATH)
	let products = ws.getProducts()
	for ware in products
		this.addMultiboardLine(ware.count.toString() + " " + ware.toString(true), ware.getIconPath())
	destroy products
	return true

init
	// Add workshop to every appropriate new unit:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_UPGRADE_FINISH, () -> GetTriggerUnit().addWorkshop())
	// Remove workshop from every appropriate removed unit:
	onUnitDeindex(() -> getIndexingUnit().removeWorkshop())
	// Adjust progress of all workshops:
	doPeriodically(PRODUCTION_ADJUSTMENT_RATE) cb ->
		for building in WORKSHOP_MAP
			if building != null
				WORKSHOP_MAP.get(building).adjustProgress()


// --------------------
// Test code
// --------------------

public function testWorkshopSystem_Workers(vec2 testCentre)
	let testName = setTestName("testWorkshopSystem_Workers", true)
	// Remove units blocking the building:
	ForGroup(GetUnitsInRectAll(testCentre.withRadiusRect(256.)), () -> GetEnumUnit().remove())
	// Create workshop:
	let unitA = createWorkshopBuilding(Settings.USER_PLAYER, UnitIdsCustom.AoW.lumberMill, testCentre, angle(0))
	let workshopA = unitA.getWorkshop()
	workshopA.getStock().addWare(ware(WareType.WOODEN_BOARDS, 4))
	workshopA.getStoredProductsCount().assertEquals(testName, 2)
	workshopA.getStoredEductsCount().assertEquals(testName, 0)
	assertNotNull(testName, workshopA)
	workshopA.getWorkerCount().assertEquals(testName, 0)
	workshopA.getWorkPower().assertEquals(testName, 0.)
	workshopA.isValidWorkerType(UnitIdsCustom.AoW.peasant).assertTrue(testName)
	// Add workers:
	let unitB = createUnit(Settings.USER_PLAYER, UnitIdsCustom.AoW.peasant, testCentre, angle(0))
	let storageA = unitB.getStorage()
	storageA.addWare(ware(WareType.WOOD, 6))
	let unitC = createUnit(Settings.USER_PLAYER, UnitIdsCustom.AoW.peasant, testCentre, angle(0))
	unitB.issueTargetOrderById(OrderIds.smart, unitA)
	unitC.issueTargetOrderById(OrderIds.smart, unitA)
	let unitD = createUnit(Settings.USER_PLAYER, UnitIdsCustom.AoW.peasant, testCentre, angle(0))
	let unitE = createUnit(Settings.USER_PLAYER, UnitIdsCustom.AoW.peasant, testCentre, angle(0))
	doAfter(MIN_ACTION_SLEEP_TIME) () ->
		// Check workshop status:
		workshopA.getWorkerCount().assertEquals(testName, 2)
		workshopA.getWorkPower().assertEquals(testName, 2.)
		workshopA.getStoredProductsCount().assertEquals(testName, 2)
		workshopA.getStoredEductsCount().assertEquals(testName, 1)
		// Add more workers:
		unitD.issueTargetOrderById(OrderIds.smart, unitA)
		unitE.issueTargetOrderById(OrderIds.smart, unitA)
	doAfter(2 * MIN_ACTION_SLEEP_TIME) () ->
		// Check workshop status:
		workshopA.getWorkerCount().assertEquals(testName, 3)
		workshopA.getWorkPower().assertEquals(testName, 3.)
		testFinish(testName)
	// Remove test units:
	doAfter(3 * MIN_ACTION_SLEEP_TIME) () ->
		unitA.kill()
		unitA.remove()
		unitB.kill()
		unitB.remove()
		unitC.kill()
		unitC.remove()
		unitD.kill()
		unitD.remove()
		unitE.kill()
		unitE.remove()

public function testWorkshopSystem_Production(vec2 testCentre)
	let testName = setTestName("testWorkshopSystem_Production", true)
	// Remove units blocking the building:
	ForGroup(GetUnitsInRectAll(testCentre.withRadiusRect(256.)), () -> GetEnumUnit().remove())
	// Create workshop:
	let unitA = createWorkshopBuilding(Settings.USER_PLAYER, UnitIdsCustom.AoW.lumberMill, testCentre, angle(0))
	let workshopA = unitA.getWorkshop()
	assertNotNull(testName, workshopA)
	workshopA.getWorkProgressPercentage().assertEquals(testName, 0.)
	workshopA.getWorkProgressLeft().assertEquals(testName, 15.)
	workshopA.getStoredEductsCount().assertEquals(testName, 0)
	workshopA.getStoredProductsCount().assertEquals(testName, 0)
	let waresA = new LinkedList<ware>()
	waresA.add(ware(WareType.WOOD, 3))
	var waresB = workshopA.getEducts()
	waresA.isEqual(waresB).assertTrue(testName)
	waresA.clear()
	waresA.add(ware(WareType.WOODEN_BOARDS, 2))
	destroy waresB
	waresB = workshopA.getProducts()
	waresA.isEqual(waresB).assertTrue(testName)
	// Change product:
	workshopA.changeProduct()
	workshopA.getWorkProgressLeft().assertEquals(testName, 10.)
	waresA.clear()
	waresA.add(ware(WareType.WOOD, 1))
	destroy waresB
	waresB = workshopA.getEducts()
	waresA.isEqual(waresB).assertTrue(testName)
	waresA.clear()
	waresA.add(ware(WareType.WOODEN_STICKS, 1))
	destroy waresB
	waresB = workshopA.getProducts()
	waresA.isEqual(waresB).assertTrue(testName)
	workshopA.changeProduct()
	workshopA.getWorkProgressLeft().assertEquals(testName, 15.)
	// Add workers directly:
	let unitB = createUnit(Settings.USER_PLAYER, UnitIdsCustom.AoW.peasant, testCentre, angle(0))
	let unitC = createUnit(Settings.USER_PLAYER, UnitIdsCustom.AoW.peasant, testCentre, angle(0))
	let unitD = createUnit(Settings.USER_PLAYER, UnitIdsCustom.AoW.peasant, testCentre, angle(0))
	workshopA.addWorker(unitB)
	workshopA.enterBuilding(unitB)
	unitB.hide()
	workshopA.addWorker(unitC)
	workshopA.enterBuilding(unitC)
	unitC.hide()
	workshopA.addWorker(unitD)
	workshopA.enterBuilding(unitD)
	unitD.hide()
	workshopA.getWorkerCount().assertEquals(testName, 3)
	// Add educts:
	waresA.clear()
	waresA.add(ware(WareType.WOOD, 7))
	workshopA.getStock().addWares(waresA)
	workshopA.getStoredEductsCount().assertEquals(testName, 2)
	workshopA.getStoredProductsCount().assertEquals(testName, 0)
	doAfter(2.) () ->
		// Check workshop status:
		workshopA.getStoredEductsCount().assertEquals(testName, 1)
		workshopA.getStoredProductsCount().assertEquals(testName, 0)
		workshopA.getWorkProgressPercentage().assertEquals(testName, 40., 2.)
		workshopA.getWorkProgressLeft().assertEquals(testName, 9., 0.3)
	doAfter(6.) () ->
		// Check workshop status:
		workshopA.getStoredEductsCount().assertEquals(testName, 0)
		workshopA.getStoredProductsCount().assertEquals(testName, 1)
		workshopA.getWorkProgressPercentage().assertEquals(testName, 20., 2.)
		workshopA.getWorkProgressLeft().assertEquals(testName, 12., 0.3)
	doAfter(11.) () ->
		// Check workshop status:
		workshopA.getStoredEductsCount().assertEquals(testName, 0)
		workshopA.getStoredProductsCount().assertEquals(testName, 2)
		workshopA.getWorkProgressPercentage().assertEquals(testName, 0.)
		workshopA.getWorkProgressLeft().assertEquals(testName, 15.)
		testFinish(testName)
	doAfter(12.) () ->
		// Remove test units:
		unitA.kill()
		unitA.remove()
		unitB.kill()
		unitB.remove()
		unitC.kill()
		unitC.remove()
		unitD.kill()
		unitD.remove()
		// Destroy class objects:
		destroy waresA
		destroy waresB