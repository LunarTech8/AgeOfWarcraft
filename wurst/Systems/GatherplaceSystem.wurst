/*-------------------------------------------------------------
// Version number:
1.0.0

// Description:
Handles gather buildings that act as drop off places and gather centres for their workers.

// Changelog:
- 1.0.0:
Initial version.
-------------------------------------------------------------*/
package GatherplaceSystem
import ConstantData
import UnitMap
import LinkedList
import Stock
import UtilityFunctions
import MultiboardPrioritySystem
import UnitIndexer
import OnUnitEnterLeave
import Icons
import RegisterEvents
import StorageSystem
import ResourceSystem
import Entity
import WorkplaceSystem


// --------------------
// Data code
// --------------------

let WORKERS_ICON_PATH = Icons.bTNBash
let RESOURCE_TARGETS_ICON_PATH = Icons.bTNReturnGoods

/** Returns the allowed target types for given gatherplace type and gather variant. */
function getTargetTypeIds(int gatherplaceUnitId, int gatherVariant) returns LinkedList<int>
	let entityIds = new LinkedList<int>()
	switch gatherplaceUnitId
		case UnitIdsCustom.AoW.lumberCamp
			switch gatherVariant
				case 1
					entityIds.add(DestructableIdsCustom.Trees.spruce)
				case 2
					entityIds.add(DestructableIdsCustom.Trees.maple)
	return entityIds

/** Returns the maximum ware capacity of the given gatherplace type. */
function getGatherplaceMaxCapacity(int gatherplaceUnitId) returns int
	switch gatherplaceUnitId
		case UnitIdsCustom.AoW.lumberCamp
			return 50
		default
			return 0


// --------------------
// Functional code
// --------------------

let GATHERPLACE_MAP = new IterableUnitHashMap<Gatherplace>(null)

public class Gatherplace extends Workplace
	private Storage storage
	private int gatherVariant

	construct(unit gatherplace)
		super(gatherplace)
		storage = new Storage(gatherplace, getGatherplaceMaxCapacity(GetUnitTypeId(gatherplace)))
		gatherVariant = 1

	ondestroy
		destroy storage

	function getStorage() returns Storage
		return storage

	function getProducts() returns LinkedList<ware>
		let wares = new LinkedList<ware>()
		for targetId in getTargetTypeIds(user.getUnitId(), gatherVariant)
			for iWare in getDefaultInitWares(targetId)
				var wareType = iWare.wareType
				for jWare in wares
					if iWare.hasSameType(jWare)
						wareType = null
						break
				if wareType != null
					wares.add(ware(wareType, 1))
		return wares

	function getTargetCount() returns int
		return findResources(user.getPos(), getTargetTypeIds(user.getUnitId(), gatherVariant)).size()

	function changeProduct()
		var allowedTypeIds = getTargetTypeIds(user.getUnitId(), gatherVariant + 1)
		if allowedTypeIds.isEmpty() == false
			gatherVariant = gatherVariant + 1
		else if gatherVariant != 1
			gatherVariant = 1
			allowedTypeIds = getTargetTypeIds(user.getUnitId(), gatherVariant)
		for worker in workers
			// worker.abortOrder()  // TEST: maybe not needed here
			worker.issueTargetAbilityOrder(AbilityIdsCustom.harvest, worker.findNextResource(allowedTypeIds).getWidget(), true)
		// TEST: check if this works and maybe write unit test for it

	function orderWorking(unit worker)
		worker.issueTargetAbilityOrder(AbilityIdsCustom.harvest, worker.findNextResource(user.getPos(), getTargetTypeIds(user.getUnitId(), gatherVariant)).getWidget(), true)

	/** Transfers as many wares as possible from this gatherplace to source storage or transfers products with reverse targets. */
	override function transferWares(Storage source, bool takeWares)
		if takeWares
			// Look for wares in gatherplace:
			let wares = storage.getWares()
			for iWare in wares
				let wareCount = min(storage.getWareCount(iWare.wareType), source.getFreeCapacity())
				if wareCount > 0
					// Transfer ware:
					storage.removeWare(ware(iWare.wareType, wareCount))
					source.addWare(ware(iWare.wareType, wareCount))
			destroy wares
		else
			// Look for products in source storage:
			let products = getProducts()
			for iWare in products
				let wareCount = min(source.getWareCount(iWare.wareType), storage.getFreeCapacity())
				if wareCount > 0
					// Transfer ware:
					source.removeWare(ware(iWare.wareType, wareCount))
					storage.addWare(ware(iWare.wareType, wareCount))
			destroy products


function unit.addGatherplace()
	if GATHERPLACE_MAP.has(this) == false and getGatherplaceMaxCapacity(this.getUnitId()) > 0
		GATHERPLACE_MAP.put(this, new Gatherplace(this))

function unit.removeGatherplace()
	let gatherplace = GATHERPLACE_MAP.tryRemove(this)
	if gatherplace != null
		destroy gatherplace

/** Returns the gatherplace of given unit. */
public function unit.getGatherplace() returns Gatherplace
	return GATHERPLACE_MAP.tryGet(this)

/** Sets system relevant infos for given object in target multiboard. */
public function multiboard.setObjectInfoMultiboard(Gatherplace gp) returns bool
	let storage = gp.getStorage()
	this.addMultiboardLine("Gatherplace:", HEADLINE_ICON_PATH)
	this.addMultiboardLine("Workers: " + gp.getWorkerCount().toString(), WORKERS_ICON_PATH)
	this.addMultiboardLine("Resource targets: " + gp.getTargetCount().toString(), RESOURCE_TARGETS_ICON_PATH)
	this.addMultiboardLine("Capacity: " + storage.getUsedCapacity().toString() + "/" + storage.getMaxCapacity().toString(), SUB_HEADLINE_ICON_PATH)
	let wares = storage.getWares()
	for ware in wares
		this.addMultiboardLine(storage.getWareCount(ware.wareType).toString() + " " + ware.toString(true), ware.getIconPath())
	destroy wares
	return true

init
	// Add gatherplace to every appropriate new unit:
	onEnter() ->
		getEnterLeaveUnit().addGatherplace()
	// Remove gatherplace from every appropriate removed unit:
	onUnitDeindex() ->
		getIndexingUnit().removeGatherplace()
	// Register construction finishes:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_UPGRADE_FINISH) ->
		GetTriggerUnit().addGatherplace()