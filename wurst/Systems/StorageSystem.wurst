/*-------------------------------------------------------------
// Version number:
1.01

// Description:
Extension of the Stock class that adds a capacity to every ware of size one and a unit type dependant max capacity.

// Changelog:
- 1.01:
Initial version.
-------------------------------------------------------------*/
package StorageSystem
import OnUnitEnterLeave
import LinkedList
import HashMap
import Icons
import ConstantDataSystem
import MultiboardPrioritySystem
import Stock


// --------------------
// Data code
// --------------------
	
let capacityIconPath = Icons.bTNSnazzyScroll

function getMaxCapacity(int unitId) returns int
	switch unitId
		case UnitIdsCustom.peasant
			return 10
		default
			return 0


// --------------------
// Functional code
// --------------------

let storageMap = new HashMap<unit, Storage>  // TODO: maybe make a general unit to class hash map system with corresponding utility functions

class Storage extends Stock
	private unit storage
	private int maxCapacity
	private int usedCapacity

	construct(unit storage, int maxCapacity)
		super(new LinkedList<ware>())
		this.storage = storage
		this.maxCapacity = maxCapacity
		usedCapacity = 0

	function getMaxCapacity() returns int
		return maxCapacity
	
	function getUsedCapacity() returns int
		return usedCapacity

	function getFreeCapacity() returns int
		return maxCapacity - usedCapacity

	function addWare(ware w) returns int  // TODO: maybe have excess checked separately
		var excess = 0
		var freeCapacity = getFreeCapacity()
		if freeCapacity > 0
			// Check and adjust capacity:
			if w.count > freeCapacity
				excess = w.count - freeCapacity
			usedCapacity += w.count - excess
			// Adjust ware:
			for iWare in wares
				if iWare.hasSameType(w)
					wares.replace(iWare, iWare.changedCopy(w.count - excess))
					// Return excess count:
					return excess
			// Add new ware if none exists of that type yet:
			wares.add(w.changedCopy(-excess))
			// Return excess count:
			return excess
		else
			// Return excess count:
			return w.count
	
	function addWares(LinkedList<ware> wares) returns int  // TODO: maybe have excess checked separately
		var excess = 0
		// Add wares:
		for iWare in wares
			excess += addWare(iWare)
		// Return excess count:
		return excess

	function removeWare(ware w) returns int  // TODO: maybe have shortage checked separately
		for iWare in wares
			if iWare.hasSameType(w)
				var shortage = 0
				// Check and adjust ware:
				if iWare.count <= w.count
					shortage = w.count - iWare.count
					wares.remove(iWare)
				else
					wares.replace(iWare, iWare.changedCopy(-w.count))
				// Adjust capacity:
				usedCapacity -= w.count - shortage
				// Return shortage count:
				return shortage
		// Return shortage count:
		return w.count


function addStorage(unit target)
	if storageMap.has(target) == false
		var maxCapacity = getMaxCapacity(GetUnitTypeId(target))
		if maxCapacity > 0
			var storage = new Storage(target, maxCapacity)
			storageMap.put(target, storage)

function removeStorage(unit target)
	if storageMap.has(target)
		destroy storageMap.get(target)
		storageMap.remove(target)

/** Returns the storage of given unit. */
public function getStorage(unit target) returns Storage
	if storageMap.has(target)
		return storageMap.get(target)
	else
		return null

/** Returns the amount of wares that couldn't be transfered. */
public function transferWares(unit source, unit target) returns int
	// Check if wares can be transfered:
	if storageMap.has(source) and storageMap.has(target)
		var sourceStorage = storageMap.get(source)
		var targetStorage = storageMap.get(target)
		// Transfere wares:
		while sourceStorage.getAmountOfWareTypes() > 0
			var ware = sourceStorage.getLastWare()
			var excess = targetStorage.addWare(ware)
			if excess < ware.count
				ware.count -= excess
				sourceStorage.removeWare(ware)
			if excess > 0
				return sourceStorage.getUsedCapacity()
		return 0
	else
		return -1

/** Sets system relevant infos for given object in target multiboard. */
public function setObjectInfoMultiboard(multiboard m, Storage s) returns bool
	addMultiboardLine(m, "Storage:", headlineIconPath)
	addMultiboardLine(m, "Capacity: " + s.getUsedCapacity().toString() + "/" + s.getMaxCapacity().toString(), capacityIconPath)
	for i = 0 to (s.getAmountOfWareTypes() - 1)
		var ware = s.getWare(i)
		addMultiboardLine(m, ware.count.toString() + " " + ware.toString(true), ware.getIconPath())
	return true

init
	// Add storage to every appropriate new unit:
	onEnter() -> 
		addStorage(getEnterLeaveUnit())
	// Remove storage from every appropriate removed unit:
	onLeave() -> 
		removeStorage(getEnterLeaveUnit())