/*-------------------------------------------------------------
// Version number:
1.01

// Description:
General unit to generic class map that allows for definition of custom utility functions and the use of different data handling solutions.
(Eg. allows use of unit index with an array instead of a hash map.)

// Changelog:
- 1.01:
Initial version.
-------------------------------------------------------------*/
package UnitMap
import HashMap
import UnitIndexer
import HashList
import ArrayList
import UnitTest
import ConstantDataSystem


// --------------------
// Functional code
// --------------------

public interface UnitMap<T>
	function has(unit key) returns bool
	function get(unit key) returns T
	function tryGet(unit key) returns T
	function put(unit key, T value)
	function remove(unit key)
	function tryRemove(unit key) returns T

public class UnitHashMap<T> implements UnitMap<T>
	protected let map = new HashMap<unit, T>

	ondestroy
		destroy map

	override function has(unit key) returns bool
		return map.has(key)

	override function get(unit key) returns T
		return map.get(key)

	/** Returns null if given key isn't mapped instead of throwing an error. */
	override function tryGet(unit key) returns T
		if map.has(key)
			return map.get(key)
		else
			return null

	override function put(unit key, T value)
		map.put(key, value)

	override function remove(unit key)
		map.remove(key)

	/** Removes and returns the value of given key. Returns null instead if given key isn't mapped. */
	override function tryRemove(unit key) returns T
		if map.has(key)
			let value = map.get(key)
			map.remove(key)
			return value
		else
			return null

public class UnitDynamicIndexMap<T> implements UnitMap<T>
	protected constant ArrayList<T> values  // Uses ArrayList as a dynamically growing array where unused slots are set to the null element
	protected constant T nullElem  // Is required because some types (like int) can't be null

	construct(T nullElem)
		values = new ArrayList<T>()
		this.nullElem = nullElem
	construct(T nullElem, int minSize)
		values = new ArrayList<T>(minSize)
		this.nullElem = nullElem
	private construct()  // Needed because IterableUnitDynamicIndexMap can't pass null element in super call
		values = new ArrayList<T>()
	private construct(int minSize)  // Needed because IterableUnitDynamicIndexMap can't pass null element in super call
		values = new ArrayList<T>(minSize)

	ondestroy
		destroy values

	override function has(unit key) returns bool
		let index = key.getIndex()  // Unindexed keys will have index 0
		return index != 0 and values.size() - 1 >= index and values.get(index) != nullElem

	override function get(unit key) returns T
		return values.get(key.toUnitIndex() castTo int)  // Indexes key if necessary so that an error is thrown if unmapped

	/** Returns the null element if given key isn't mapped instead of throwing an error. */
	override function tryGet(unit key) returns T
		let index = key.getIndex()  // Unindexed keys will have index 0
		if index == 0 or values.size() - 1 < index
			return nullElem
		return values.get(index)

	override function put(unit key, T value)
		values.setWithResize(key.toUnitIndex() castTo int, value, nullElem)  // Automatically indexes key if previously unmapped

	override function remove(unit key)
		values.set(key.toUnitIndex() castTo int, nullElem)  // Automatically indexes key if previously unmapped

	/** Removes and returns the value of given key. Returns the null element instead if given key isn't mapped. */
	override function tryRemove(unit key) returns T
		let index = key.getIndex()  // Unindexed keys will have index 0
		if index != 0 and values.size() - 1 >= index
			let value = values.get(index)
			values.set(index, nullElem)
			return value
		else
			return nullElem

public class UnitFixedIndexMap<T> implements UnitMap<T>
	protected let size = 8192
	protected T array[size] values

	construct()
		values[0] = null  // Null first slot for unindexed units

	override function has(unit key) returns bool
		return values[key.getIndex()] != null  // Unindexed keys will use first nulled slot

	override function get(unit key) returns T
		return values[key.toUnitIndex() castTo int]  // Indexes key if necessary so that an error is thrown if unmapped

	/** Returns null if given key isn't mapped instead of throwing an error. */
	override function tryGet(unit key) returns T
		return values[key.getIndex()]  // Will return null if key isn't indexed

	override function put(unit key, T value)
		values[key.toUnitIndex() castTo int] = value  // Automatically indexes key if previously unmapped

	override function remove(unit key)
		values[key.toUnitIndex() castTo int] = null  // Automatically indexes key if previously unmapped

	/** Removes and returns the value of given key. Returns null instead if given key isn't mapped. */
	override function tryRemove(unit key) returns T
		let index = key.getIndex()
		if index != 0
			let value = values[index]
			values[index] = null
			return value
		else
			return null

public class IterableUnitHashMap<T> extends UnitHashMap<T>
	protected let keys = new HashList<unit>

	ondestroy
		destroy keys

	/** Returns an iterator that iterates over the map's keys. */
	function iterator() returns HLIterator<unit>
		return keys.iterator()

	/** Returns the length of this iterable map. */
	function size() returns int
		return keys.size()

	/** Saves the given value under the given key. */
	override function put(unit key, T value)
		super.put(key, value)
		if keys.has(key) == false
			keys.add(key)

	/** Removes the key-value pair saved under the given key. */
	override function remove(unit key)
		super.remove(key)
		keys.remove(key)

	/** Removes and returns the value of given key. Returns null instead if given key isn't mapped. */
	override function tryRemove(unit key) returns T
		if keys.has(key)
			let value = super.get(key)
			super.remove(key)
			keys.remove(key)
			return value
		else
			return null

public class IterableUnitDynamicIndexMap<T> extends UnitDynamicIndexMap<T>
	protected constant ArrayList<unit> keys

	construct(T nullElem)
		super()
		this.nullElem = nullElem  // Needed because null element can't be passed in super call
		keys = new ArrayList<unit>()
	construct(T nullElem, int minSize)
		super(minSize)
		this.nullElem = nullElem  // Needed because null element can't be passed in super call
		keys = new ArrayList<unit>(minSize)

	ondestroy
		destroy keys

	/** Returns an iterator that iterates over the map's keys. */
	function iterator() returns ALIterator<unit>
		return keys.iteratorIgnoreNull(null)

	/** Returns the length of this iterable map. */
	function size() returns int
		return keys.size()

	/** Saves the given value under the given key. */
	override function put(unit key, T value)
		super.put(key, value)
		keys.setWithResize(key.toUnitIndex() castTo int, key, null)  // Automatically indexes key if previously unmapped

	/** Removes the key-value pair saved under the given key. */
	override function remove(unit key)
		super.remove(key)
		keys.set(key.toUnitIndex() castTo int, null)  // Automatically indexes key if previously unmapped

	/** Removes and returns the value of given key. Returns null instead if given key isn't mapped. */
	override function tryRemove(unit key) returns T
		let index = key.getIndex()  // Unindexed keys will have index 0
		if index != 0
			let value = super.get(key)
			super.remove(key)
			keys.set(index, null)
			return value
		else
			return null


// --------------------
// Test code
// --------------------

@Test public function testUnitDynamicIndexMap_AddAndRemove()
	let testName = "testUnitDynamicIndexMap_AddAndRemove"
	// Create new map:
	let a = new UnitDynamicIndexMap<string>(null, 4)
	a.has(null).assertFalse(testName)
	// Add entries and check:
	let unitA = createUnit(DUMMY_PLAYER, UnitIdsCustom.peasant, vec2(0, 0), angle(0))
	a.put(unitA, "unitA")
	a.get(unitA).assertEquals(testName, "unitA")
	a.has(unitA).assertTrue(testName)
	let unitB = createUnit(DUMMY_PLAYER, UnitIdsCustom.peasant, vec2(0, 0), angle(0))
	a.put(unitB, "unitB")
	a.get(unitB).assertEquals(testName, "unitB")
	// Remove entry and check:
	a.remove(unitA)
	a.has(unitA).assertFalse(testName)
	a.tryGet(unitA).assertEquals(testName, null)
	a.tryRemove(unitA).assertEquals(testName, null)
	a.get(unitB).assertEquals(testName, "unitB")
	a.tryGet(unitB).assertEquals(testName, "unitB")
	let unitC = createUnit(DUMMY_PLAYER, UnitIdsCustom.peasant, vec2(0, 0), angle(0))
	a.put(unitC, "unitC")
	a.tryRemove(unitC).assertEquals(testName, "unitC")
	// Create another map:
	let b = new UnitDynamicIndexMap<int>(0, 2)
	b.has(unitB).assertFalse(testName)
	b.put(unitA, 1)
	b.get(unitA).assertEquals(testName, 1)
	a.has(unitA).assertFalse(testName)
	b.put(unitB, 2)
	b.put(unitC, 3)
	b.get(unitC).assertEquals(testName, 3)
	// Remove test units:
	RemoveUnit(unitA)
	RemoveUnit(unitB)
	RemoveUnit(unitC)