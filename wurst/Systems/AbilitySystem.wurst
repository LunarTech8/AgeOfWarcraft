/*-------------------------------------------------------------
// Version number:
1.0.0

// Description:
Handles all custom abilities and allows for the addition of custom, unrestricted functionality.

// Changelog:
- 1.0.0:
Initial version.
-------------------------------------------------------------*/
package AbilitySystem
import RegisterEvents
import ConstantDataSystem
import UtilityFunctions
import Stock
import StorageSystem
import BuildingSystem
import ResourceSystem
import OrderSystem
import Ability_Harvest
import InstantDummyCaster
import DummyRecycler
import ClosureTimers
import WorkshopSystem


// --------------------
// Data code
// --------------------

let INFO_MSG_TIME = 2.

enum Validity
	VALID
	UNREGISTERED
	INVALID_SOURCE
	INVALID_TARGET
	WARES_NOT_AVAILABLE
	NO_FREE_WORK_SLOT
	NO_FREE_STORAGE
	NO_REQUIRED_WARES
	WORKER_ALREADY_BUILDING
	RESOURCE_IS_DEPLETED

function getInvalidMessageText(int abilityId, Validity val) returns string
	switch abilityId
		case AbilityIdsCustom.transferWares
			switch val
				case INVALID_SOURCE
					return "Unit can't transfer wares"
				case INVALID_TARGET
					return "Can't transfer wares to this kind of target"
				case WARES_NOT_AVAILABLE
					return "No wares to transfer are available"
				case NO_FREE_STORAGE
					return "Target has no free storage for transfer"
				case NO_REQUIRED_WARES
					return "Target has no required wares left"
				default
					return null
		case AbilityIdsCustom.build
			switch val
				case INVALID_SOURCE
					return "Worker can't build at target building site type"
				case INVALID_TARGET
					return "Build target is no building site"
				case WARES_NOT_AVAILABLE
					return "Not all required wares are available for building"
				case WORKER_ALREADY_BUILDING
					return "Worker is already building"
				default
					return null
		case AbilityIdsCustom.harvest
			switch val
				case INVALID_SOURCE
					return "No storage for harvest"
				case INVALID_TARGET
					return "Harvest target is no resource"
				case NO_FREE_WORK_SLOT
					return "Target already reached its maximum of concurrent harvesters"
				case NO_FREE_STORAGE
					return "No free storage for harvest"
				case RESOURCE_IS_DEPLETED
					return "Harvest target is already depleted"
				default
					return null
	return null


// --------------------
// Functional code
// --------------------

/** Perform harvest and returns if another harvest with the given target is still valid. */
function unit.harvest(unit target) returns bool
	let storage = this.getStorage()
	let resource = target.getResource()
	// Work resource:
	let wares = resource.harvest(this.getUnitId())
	if wares != null
		// Transfere wares:
		for iWare in wares
			// Check resource count:
			var resourceWareCount = resource.getWareCount(iWare.wareType)
			var freeCapacity = storage.getFreeCapacity()
			if resourceWareCount > 0 and freeCapacity > 0
				// Limit by resource count:
				if resourceWareCount < iWare.count
					iWare.count = resourceWareCount
				// Limit by storage free capacity:
				if freeCapacity < iWare.count
					iWare.count = freeCapacity
				// Add ware to storage and remove from resource:
				storage.addWare(iWare)
				resource.removeWare(iWare)
		destroy wares
		// Check for resource depletion:
		if resource.checkForDepletionKill()
			target.kill()
			return false
	return this.isAbilityValid(AbilityIdsCustom.harvest, target)

/** Transfer wares from the unit to the given target. */
function unit.transferWares(unit target)
	// Check if wares can be transfered:
	var sourceStorage = this.getStorage()
	if sourceStorage != null
		// Check for possible transfer methods based on target:
		var targetStorage = target.getStorage()
		if targetStorage != null
			// Give wares to target storage:
			sourceStorage.transferWares(targetStorage)
		var targetWorkshop = target.getWorkshop()
		if targetWorkshop != null
			// Give wares to target workshop:
			sourceStorage.transferWares(targetWorkshop)
		var targetBuildingSite = target.getBuildingSite()
		if targetBuildingSite != null
			// Take wares from source storage:
			targetBuildingSite.transferWares(sourceStorage)
			// Call over idel workers if no required wares are missing:
			if targetBuildingSite.isEmpty()
				targetBuildingSite.callOverIdleWorkers(this)

/** Run general reaction on invalid ability command. */
function unit.reactOnInvalidAbility(int abilityId, Validity val)
	if val == Validity.VALID or val == Validity.UNREGISTERED
		Log.error("ERROR: Given validity is not invalid (" + (val castTo int).toString() + ")")

	// React on invalid command:
	let owner = this.getOwner()
	if IsUnitSelected(this, owner)
		let messageText = getInvalidMessageText(abilityId, val)
		if messageText == null
			Log.error("ERROR: Unregistered invalidity message text for " + abilityId.toString() + " / " + (val castTo int).toString())
		printTimedToPlayer("Invalid: " + messageText, INFO_MSG_TIME, owner)
	this.abortOrder()

/** Returns the units validity for casting given ability on given target. */
function unit.getAbilityValidity(int abilityId, unit target) returns Validity
	if abilityId == AbilityIdsCustom.transferWares
		// Check if source and target are valid:
		let sourceStorage = this.getStorage()
		if sourceStorage == null
			return Validity.INVALID_SOURCE
		let targetStorage = target.getStorage()
		let targetWorkshop = target.getWorkshop()
		let targetBuildingSite = target.getBuildingSite()
		if targetStorage == null and targetWorkshop == null and targetBuildingSite == null
			return Validity.INVALID_TARGET
		// Check if wares are available:
		if sourceStorage.getUsedCapacity() <= 0
			return Validity.WARES_NOT_AVAILABLE
		// Check if target has free storage:
		if (targetStorage != null or targetWorkshop != null) and targetStorage.getFreeCapacity() <= 0
			return Validity.NO_FREE_STORAGE
		// Check if target requires wares:
		if targetBuildingSite != null and targetBuildingSite.isEmpty()
			return Validity.NO_REQUIRED_WARES
	else if abilityId == AbilityIdsCustom.build
		// Check if source and target are valid:
		if target.getUnitId().isValidWorkerType(this.getUnitId()) == false
			return Validity.INVALID_SOURCE
		var buildingSite = target.getBuildingSite()
		if buildingSite == null
			return Validity.INVALID_TARGET
		// Check if required wares are available:
		if buildingSite.isEmpty() == false
			return Validity.WARES_NOT_AVAILABLE
		// Check if worker is already building:
		if this.getBuildingSiteOfWorker() != null
			return Validity.WORKER_ALREADY_BUILDING
	else if abilityId == AbilityIdsCustom.harvest
		// Check if source and target are valid:
		var storage = this.getStorage()
		if storage == null
			return Validity.INVALID_SOURCE
		var resource = target.getResource()
		if resource == null
			return Validity.INVALID_TARGET
		// Check if wares can be harvested:
		if storage.getFreeCapacity() <= 0
			return Validity.NO_FREE_STORAGE
		else if resource.isEmpty()
			return Validity.RESOURCE_IS_DEPLETED
		else if resource.getFreeWorkerSlots() <= 0
			return Validity.NO_FREE_WORK_SLOT
	else
		// Unregistered abilityId:
		return Validity.UNREGISTERED
	// No validity check failed:
	return Validity.VALID

/** Returns if casting given ability by the unit on given target is valid. */
public function unit.isAbilityValid(int abilityId, unit target) returns bool
	return this.getAbilityValidity(abilityId, target) == Validity.VALID

init
	// Register abilities being cast:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CAST) ->
		let source = GetTriggerUnit()
		let target = GetSpellTargetUnit()
		let abilityId = GetSpellAbilityId()
		let sourceUnitId = source.getUnitId()
		if sourceUnitId != DUMMY_CASTER_UNIT_ID and sourceUnitId != DUMMY_UNIT_ID  // Ignore dummy orders
			// Cancel current target order for clean cast validity and ordering:
			let orderSource = source.getOrderSource()
			if orderSource == null
				Log.warn("WARNING: " + source.getName() + " cast " + abilityId.getOrderName() + " on " + target.getName() + " without being registered as an OrderSource")
			else
				orderSource.cancel()
			// Check ability validity:
			let val = source.getAbilityValidity(abilityId, target)
			if val == Validity.VALID
				switch abilityId
					case AbilityIdsCustom.transferWares
						// Transfer wares from source to target:
						source.transferWares(target)
					case AbilityIdsCustom.build
						// Add worker to building site:
						let targetBuildingSite = target.getBuildingSite()
						CallbackSimple invalidateCb = () ->
							doAfter(MIN_TRIGGER_SLEEP_TIME, () -> source.issueTargetAbilityOrder(AbilityIdsCustom.build, source.findNextBuildingSite(), true))
						CallbackSimple cancelCb = () ->
							targetBuildingSite.removeWorker(source)
						source.setOrder(AbilityIdsCustom.build, target, new OrderAction(invalidateCb, cancelCb))
						targetBuildingSite.addWorker(source)
					case AbilityIdsCustom.harvest
						// Perform harvest after ability is finished:
						let targetResource = target.getResource()
						CallbackSimple invalidateCb = () ->
							source.issueTargetAbilityOrder(AbilityIdsCustom.harvest, source.findNextResource(), true)
						CallbackSimple cancelCb = () ->
							targetResource.removeWorker()
						CallbackSimple finishCb = () ->
							targetResource.removeWorker()
							if source.harvest(target)
								source.issueTargetAbilityOrder(AbilityIdsCustom.harvest, target, true)  // Auto-recast on same target
							else
								source.issueTargetAbilityOrder(AbilityIdsCustom.harvest, source.findNextResource(), true)  // Find and auto-recast on new target
						source.setOrder(AbilityIdsCustom.harvest, target, new OrderAction(invalidateCb, cancelCb, finishCb, AbilityData_Harvest.cooldown, null))
						targetResource.addWorker()
			else if val != Validity.UNREGISTERED
				source.reactOnInvalidAbility(abilityId, val)
	// Register issued ability orders:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER) ->
		let issuedOrderId = GetIssuedOrderId()
		let source = GetOrderedUnit()
		// Check for custom ability:
		let orderName = issuedOrderId.getOrderName(source, true)
		if orderName != null
			let target = GetOrderTargetUnit()
			if target != null
				// Override registered order in OrderSystem to add fitting OrderAction and target handling (works because through the dependency this function is called afterwards):
				let abilityId = orderName.getOrderNameAbility()
				let val = source.getAbilityValidity(abilityId, target)
				if val == Validity.VALID
					switch orderName
						case "harvest"
							let targetResource = target.getResource()
							source.setOrder(issuedOrderId, target, new OrderAction(() -> source.issueTargetAbilityOrder(AbilityIdsCustom.harvest, source.findNextResource(), true), () -> targetResource.removeWorker()))
							targetResource.addWorker()  // Reserve worker slot to avoid that too many workers target the same resource
						case "build"
							source.setOrder(issuedOrderId, target, new OrderAction(() -> source.issueTargetAbilityOrder(AbilityIdsCustom.build, source.findNextBuildingSite(), true), null))
				else if val != Validity.UNREGISTERED
					source.reactOnInvalidAbility(abilityId, val)