/*-------------------------------------------------------------
// Version number:
1.0.0

// Description:
Handles world map generation like terrain deformation and unit placement.

// Changelog:
- 1.0.0:
Initial version.
-------------------------------------------------------------*/
package WorldGenerationSystem
import TerrainUtils
import Interpolation
import Array2D
import ConstantData
import UtilityFunctions
import Entity
import ResourceSystem
import LoadStatusSystem
import ComputationControl
import Destructable_Spruce
import NoiseFunctions


// --------------------
// Data code
// --------------------

// General:
let TILES_X = 104
let TILES_Y = 104
let ORIGIN_VEC = vec2(-6656., -7168.)  // Left, bottom point from which the terrain generation starts towards right, top point

// Terrain:
let TERRAIN_HEIGHT_INIT = 0.
let TERRAIN_HEIGHT_MIN = -64.  // Min HEIGHT_DEEP_WATER_MIN
let TERRAIN_HEIGHT_MAX = HEIGHT_LAND_MIN + 786.  // Max HEIGHT_LAND_MAX

// Plants:
let NATURE_PLAYER = Player(PLAYER_NEUTRAL_PASSIVE)

enum PlantBiomeType
	BARRENS
	MEADOW
	SHRUBLAND
	WOODS
	FOREST

function getPlantBiomeType(real plantNoiseValue) returns PlantBiomeType
	if plantNoiseValue >= 0.8
		return PlantBiomeType.FOREST
	else if plantNoiseValue >= 0.6
		return PlantBiomeType.WOODS
	else if plantNoiseValue >= 0.4
		return PlantBiomeType.SHRUBLAND
	else if plantNoiseValue >= 0.2
		return PlantBiomeType.MEADOW
	else
		return PlantBiomeType.BARRENS


// --------------------
// Functional code
// --------------------

Array2DReal heightMap = new Array2DReal(TILES_X, TILES_Y)
Array2DInt plantMap = new Array2DInt(TILES_X, TILES_Y)

public function generateNoiseMaps()
	// Create height map:
	newInitStatus("Height map creation")
	var noiseMap = generatePerlinNoise(TILES_X, TILES_Y, 7, 0.6, "Cosine")
	newInitSubStatus("Calculate height map")
	newInitSubStatus("Test5 " + computationCost.toString())  // DEBUG:
	for	x = 0 to TILES_X - 1
		setInitStepStatus(x + 1, TILES_X)
		for	y = 0 to TILES_Y - 1
			heightMap.set(x, y, linear(TERRAIN_HEIGHT_MIN, TERRAIN_HEIGHT_MAX, noiseMap.get(x, y)))
			computationCost += 0.069
		checkForComputationBreak()
	forceComputationBreak()
	destroy noiseMap
	forceComputationBreak()
	// Create plant map:
	newInitStatus("Plant map creation")
	noiseMap = generatePerlinNoise(TILES_X, TILES_Y, 5, 0.6, "Cosine")
	newInitSubStatus("Calculate plant map")
	newInitSubStatus("Test6 " + computationCost.toString())  // DEBUG:
	for	x = 0 to TILES_X - 1
		setInitStepStatus(x + 1, TILES_X)
		for	y = 0 to TILES_Y - 1
			plantMap.set(x, y, getPlantBiomeType(noiseMap.get(x, y)) castTo int)
			computationCost += 0.067
		checkForComputationBreak()
	forceComputationBreak()
	destroy noiseMap

public function createTerrain()
	newInitStatus("Terrain creation")
	// Adjust the height for each tile:
	newInitSubStatus("Adjust terrain heights")
	newInitSubStatus("Test7 " + computationCost.toString())  // DEBUG:
	for	x = 0 to TILES_X - 1
		setInitStepStatus(x + 1, TILES_X)
		for	y = 0 to TILES_Y - 1
			let z = heightMap.get(x, y)
			let pos = ORIGIN_VEC.add(x * TILE_DISTANCE, y * TILE_DISTANCE)
			pos.addTerrainHeight(z - TERRAIN_HEIGHT_INIT)  // Terrain has to have water on it before hand for it to show up
			let tile = pos.getTile()
			// Assert that pathing is set to deep water beforehand
			if z >= HEIGHT_LAND_MIN
				tile.setPathing(PATHING_TYPE_FLOATABILITY, false)
				tile.setPathing(PATHING_TYPE_WALKABILITY, true)
				tile.setPathing(PATHING_TYPE_BUILDABILITY, true)
			else if z >= HEIGHT_SHALLOW_WATER_MIN
				tile.setPathing(PATHING_TYPE_WALKABILITY, true)
				tile.setPathing(PATHING_TYPE_BUILDABILITY, false)
			computationCost += 0.821
		checkForComputationBreak()

public function createPlants()
	newInitStatus("Plants creation")
	// Have 1 or 0 tree per tile:
	newInitSubStatus("Add trees")
	newInitSubStatus("Test8 " + computationCost.toString())  // DEBUG:
	for	x = 0 to TILES_X - 1
		setInitStepStatus(x + 1, TILES_X)
		for	y = 0 to TILES_Y - 1
			let plantBiome = plantMap.get(x, y) castTo PlantBiomeType
			if plantBiome == FOREST
				let pos = ORIGIN_VEC + vec2(x + GetRandomReal(-0.5, 0.5), y + GetRandomReal(-0.5, 0.5)) * TILE_DISTANCE
				// createUnit(NATURE_PLAYER, UnitIdsCustom.Trees.beech.getUnitTypeId(), pos, getRandomAngle())  // DEBUG:
				// entity(null, createDestructable(DestructableIdsCustom.Trees.spruce, pos, getRandomAngle(), GetRandomReal(DestructableData_Spruce.minScale, DestructableData_Spruce.maxScale), getRandomVariation(DestructableData_Spruce.variations))).tryAddResouce()
				entity(null, createDestructable(DestructableIdsCustom.Trees.spruce, pos, getRandomAngle(), DestructableData_Spruce.maxScale, getRandomVariation(DestructableData_Spruce.variations))).tryAddResouce()
			else if plantBiome == WOODS
				let pos = ORIGIN_VEC + vec2(x + GetRandomReal(-0.5, 0.5), y + GetRandomReal(-0.5, 0.5)) * TILE_DISTANCE
				entity(null, createDestructable(DestructableIdsCustom.Trees.spruce, pos, getRandomAngle(), DestructableData_Spruce.minScale, getRandomVariation(DestructableData_Spruce.variations))).tryAddResouce()
			computationCost += 0.206
		checkForComputationBreak()