/*-------------------------------------------------------------
// Version number:
1.01

// Description:
Handles all custom abilities and allows for the addition of custom, unrestricted functionality.

// Changelog:
- 1.01:
Initial version.
-------------------------------------------------------------*/
package AbilitySystem
import RegisterEvents
import ClosureTimers
import ConstantDataSystem
import UtilityFunctions
import Stock
import StorageSystem
import BuildingSystem
import ResourceSystem
import Ability_Harvest


// --------------------
// Data code
// --------------------

let infoMsgTime = 2.


// --------------------
// Functional code
// --------------------

/** Perform harvest and returns if another harvest with the given target is still valid. */
function performHarvest(unit worker, unit target) returns bool
	let storage = getStorage(worker)
	let resource = getResource(target)
	// Work resource:
	let wares = resource.harvest(getUnitId(worker))
	if wares != null
		// Transfere wares:
		for iWare in wares
			// Check resource count:
			let resourceWareCount = resource.getWareCount(iWare.wareType)
			if resourceWareCount > 0
				// Limit by resource count:
				if resourceWareCount < iWare.count
					iWare.count = resourceWareCount
				// Add ware to storage:
				var excess = storage.addWare(iWare)
				// Remove ware from resource:
				if excess < iWare.count
					iWare.count -= excess
					resource.removeWare(iWare)
		destroy wares
		// Check for resource depletion:
		if resource.checkForDepletionKill()
			target.kill()
			return false
	return getHarvestValidity(worker, target) == 1
		
/** Returns harvest validity: 1=Valid 2=InvalidWorker 3=InvalidTarget 4=NoFreeStorage 5=ResourceIsDepleted */
public function getHarvestValidity(unit worker, unit target) returns int
	// Check if source and target are valid:
	var storage = getStorage(worker)
	if storage == null
		return 2
	var resource = getResource(target)
	if resource == null
		return 3
	// Check if wares can be harvested:
	if storage.getFreeCapacity() <= 0
		return 4
	else if resource.getAmountOfWareTypes() <= 0
		return 5
	else
		return 1
		
/** Returns build validity: 1=Valid 2=InvalidWorker 3=InvalidTarget 4=WaresNotAvailable 5=WorkerAlreadyBuilding */
public function getBuildValidity(unit worker, unit target) returns int
	// Check if source and target are valid:
	if isValidWorkerType(getUnitId(worker), getUnitId(target)) == false
		return 2
	var buildingSite = getBuildingSite(target)
	if buildingSite == null
		return 3
	// Check if required wares are available:
	if buildingSite.hasNoRequiredWaresLeft() == false
		return 4
	// Check if worker is already building:
	if getBuildingSiteOfWorker(worker) != null
		return 5
	else
		return 1
		
init
	// Register transferWares spell:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CAST, () -> GetSpellAbilityId() == AbilityIdsCustom.transferWares) ->
		transferWares(GetTriggerUnit(), GetSpellTargetUnit())
	// Register build spell:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CAST, () -> GetSpellAbilityId() == AbilityIdsCustom.build) ->
		let worker = GetTriggerUnit()
		let target = GetSpellTargetUnit()
		let validity = getBuildValidity(worker, target)
		if validity != 1
			// React on invalid command:
			let owner = worker.getOwner()
			if IsUnitSelected(worker, owner)
				switch validity
					case 2  // InvalidWorker
						printTimedToPlayer("Invalid: Worker can't build at target building site type", infoMsgTime, owner)
					case 3  // InvalidTarget
						printTimedToPlayer("Invalid: Build target is no building site", infoMsgTime, owner)
					case 4  // WaresNotAvailable
						printTimedToPlayer("Invalid: Not all required wares are available", infoMsgTime, owner)
					case 5  // WorkerAlreadyBuilding
						printTimedToPlayer("Invalid: Worker is already building", infoMsgTime, owner)
			worker.abortOrder()
		else
			getBuildingSite(target).addWorker(worker)
	// Register harvest spell:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CAST, () -> GetSpellAbilityId() == AbilityIdsCustom.harvest) ->
		let worker = GetTriggerUnit()
		let target = GetSpellTargetUnit()
		let validity = getHarvestValidity(worker, target)
		if validity != 1
			// React on invalid command:
			switch validity
				case 2  // InvalidWorker
					printTimedToPlayer("Invalid: No storage for harvest", infoMsgTime, worker.getOwner())
				case 3  // InvalidTarget
					printTimedToPlayer("Invalid: Harvest target is no resource", infoMsgTime, worker.getOwner())
				case 4  // NoFreeStorage
					printTimedToPlayer("Invalid: No free storage for harvest", infoMsgTime, worker.getOwner())
				case 5  // ResourceIsDepleted
					printTimedToPlayer("Invalid: Harvest target is already depleted", infoMsgTime, worker.getOwner())
			worker.abortOrder()
		else
			// Perform harvest after ability casting is finished:
			doAfter(AbilityData_Harvest.cooldown) ->
				if performHarvest(worker, target)
					// Auto-recast ability:
					worker.issueTargetAbilityOrder(AbilityIdsCustom.harvest, target, true)