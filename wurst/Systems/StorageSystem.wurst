/*-------------------------------------------------------------
// Version number:
1.01

// Description:
Extension of the Stock class that adds a capacity to every ware of size one and a unit type dependant max capacity.

// Changelog:
- 1.01:
Initial version.
-------------------------------------------------------------*/
package StorageSystem
import OnUnitEnterLeave
import LinkedList
import HashMap
import Icons
import ConstantDataSystem
import MultiboardPrioritySystem
import Stock


// --------------------
// Data code
// --------------------

let capacityIconPath = Icons.bTNSnazzyScroll

function getMaxCapacity(int unitId) returns int
	switch unitId
		case UnitIdsCustom.peasant
			return 10
		default
			return 0


// --------------------
// Functional code
// --------------------

let storageMap = new HashMap<unit, Storage>  // TODO: maybe make a general unit to class hash map system with corresponding utility functions

public class Storage extends Stock
	private unit storage
	private int maxCapacity
	private int usedCapacity

	construct(unit storage, int maxCapacity)
		super(new LinkedList<ware>())
		this.storage = storage
		this.maxCapacity = maxCapacity
		usedCapacity = 0

	function getMaxCapacity() returns int
		return maxCapacity

	function getUsedCapacity() returns int
		return usedCapacity

	function getFreeCapacity() returns int
		return maxCapacity - usedCapacity

	function addWare(ware w) returns int  // TODO: maybe have excess checked separately
		var excess = 0
		var freeCapacity = getFreeCapacity()
		if freeCapacity > 0
			// Check and adjust capacity:
			if w.count > freeCapacity
				excess = w.count - freeCapacity
			usedCapacity += w.count - excess
			// Adjust ware:
			for iWare in wares
				if iWare.hasSameType(w)
					wares.replace(iWare, iWare.changedCopy(w.count - excess))
					// Return excess count:
					return excess
			// Add new ware if none exists of that type yet:
			wares.add(w.changedCopy(-excess))
			// Return excess count:
			return excess
		else
			// Return excess count:
			return w.count

	function addWares(LinkedList<ware> wares) returns int  // TODO: maybe have excess checked separately
		var excess = 0
		// Add wares:
		for iWare in wares
			excess += addWare(iWare)
		// Return excess count:
		return excess

	function removeWare(ware w) returns int  // TODO: maybe have shortage checked separately
		for iWare in wares
			if iWare.hasSameType(w)
				var shortage = 0
				// Check and adjust ware:
				if iWare.count <= w.count
					shortage = w.count - iWare.count
					wares.remove(iWare)
				else
					wares.replace(iWare, iWare.changedCopy(-w.count))
				// Adjust capacity:
				usedCapacity -= w.count - shortage
				// Return shortage count:
				return shortage
		// Return shortage count:
		return w.count

	/** Returns the amount of wares that couldn't be transfered. */
	function transferWares(Storage target) returns int
		// Transfer last ware of source until it is empty or target is full:
		while hasWares()
			var ware = getLastWare()
			var excess = target.addWare(ware)
			if excess < ware.count
				ware.count -= excess
				removeWare(ware)
			if excess > 0
				return usedCapacity
		return 0


function unit.addStorage()
	if storageMap.has(this) == false
		var maxCapacity = getMaxCapacity(GetUnitTypeId(this))
		if maxCapacity > 0
			var storage = new Storage(this, maxCapacity)
			storageMap.put(this, storage)

function unit.removeStorage()
	if storageMap.has(this)
		destroy storageMap.get(this)
		storageMap.remove(this)

/** Returns the storage of given unit. */
public function unit.getStorage() returns Storage
	if storageMap.has(this)
		return storageMap.get(this)
	else
		return null

/** Sets system relevant infos for given object in target multiboard. */
public function multiboard.setObjectInfoMultiboard(Storage s) returns bool
	this.addMultiboardLine("Storage:", headlineIconPath)
	this.addMultiboardLine("Capacity: " + s.getUsedCapacity().toString() + "/" + s.getMaxCapacity().toString(), capacityIconPath)
	for i = 0 to (s.getAmountOfWareTypes() - 1)
		var ware = s.getWare(i)
		this.addMultiboardLine(ware.count.toString() + " " + ware.toString(true), ware.getIconPath())
	return true

init
	// Add storage to every appropriate new unit:
	onEnter() ->
		getEnterLeaveUnit().addStorage()
	// Remove storage from every appropriate removed unit:
	onLeave() ->
		getEnterLeaveUnit().removeStorage()