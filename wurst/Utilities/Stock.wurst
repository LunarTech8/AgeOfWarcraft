/*-------------------------------------------------------------
// Version number:
1.0.0

// Description:
Manages the type and count of wares that are associated with each unit.
Base class that should be extended into specialised classes.

// Changelog:
- 1.0.0:
Initial version.
-------------------------------------------------------------*/
package Stock
import Icons
import ArrayList


// --------------------
// Data code
// --------------------

let MAX_COUNT = 99999  // Is limited to allow tuple to be converted into a single int
let MAX_WARE_TYPES = 9999  // Is limited to allow tuple to be converted into a single int

public enum WareType
	WOOD
	STONE
	FOOD
	WOODEN_BOARD
	WOODEN_STICK
	STRAW

function WareType.toString() returns string
	switch this
		case WOOD
			return "wood"
		case STONE
			return "stone"
		case FOOD
			return "food"
		case STRAW
			return "straw"
		default
			return "undefined ware"

function WareType.getIconPath() returns string
	switch this
		case WOOD
			return Icons.bTNBundleOfLumber
		case STONE
			return "Icons\\BTNINV_Stone_12.blp"
		case FOOD
			return Icons.bTNMonsterLure
		case WOODEN_BOARD
			return Icons.bTNHumanLumberUpgrade2
		case WOODEN_STICK
			return Icons.bTNHumanLumberUpgrade1
		case STRAW
			return "Icons\\BTNStrawBunch.blp"
		default
			return null


// --------------------
// Functional code
// --------------------

public tuple ware(WareType wareType, int count)

public function wareToIndex(ware w) returns int
	let wareTypeInt = w.wareType castTo int
	if w.count < 1 or w.count > MAX_COUNT
		Log.error("ERROR: Ware count (" + w.count.toString() + ") isn't allowed to be smaller than 1 or bigger than " + MAX_COUNT.toString())
	else if wareTypeInt < 0 or wareTypeInt > MAX_WARE_TYPES
		Log.error("ERROR: Ware type (" + wareTypeInt.toString() + ") isn't allowed to be smaller than 0 or bigger than " + MAX_WARE_TYPES.toString())
	return w.count + wareTypeInt * (MAX_COUNT + 1)

public function wareFromIndex(int index) returns ware
	let count = index mod (MAX_COUNT + 1)
	let wareType = ((index - count) div (MAX_COUNT + 1)) castTo WareType
	return ware(wareType, count)

public function ware.hasSameType(ware otherWare) returns bool
	return (this.wareType == otherWare.wareType)

public function ware.toString(bool upperCase) returns string
	if upperCase
		return this.wareType.toString().firstUpper()
	else
		return this.wareType.toString()

public function ware.getIconPath() returns string
	return this.wareType.getIconPath()

public function ware.changedCopy(int countChange) returns ware
	return ware(this.wareType, this.count + countChange)
public function ware.changedCopy(WareType newWareType) returns ware
	return ware(newWareType, this.count)
public function ware.changedCopy(WareType newWareType, int countChange) returns ware
	return ware(newWareType, this.count + countChange)

public class Stock
	protected ArrayList<ware> wares
	protected unit user

	construct(ArrayList<ware> wares)
		this.wares = wares

	ondestroy
		destroy wares

	/** Returns if the stock has any wares. */
	function hasWares() returns bool
		return wares.isEmpty() == false

	/** Returns the ware by given index of the stock. */
	function getWare(int index) returns ware
		if index >= wares.size()
			Log.error("ERROR: Index has to be smaller than list size")
		return wares.get(index)

	/** Returns the last ware of the stock. */
	function getLastWare() returns ware
		return wares.peek()

	/** Returns amount of different ware types in the stock. */
	function getAmountOfWareTypes() returns int
		return wares.size()

	/** Returns count of given ware type. */
	function getWareCount(WareType wt) returns int
		for iWare in wares
			if iWare.wareType == wt
				return iWare.count
		return 0

	/** Add given wares to the stock. */
	function addWare(ware w)
		// Adjust ware:
		for iWare in wares
			if iWare.hasSameType(w)
				wares.replace(iWare, iWare.changedCopy(w.count))
				return
		// Add new ware if none exists of that type yet:
		wares.add(w)

	/** Add given wares to the stock. */
	function addWares(ArrayList<ware> wares)
		for iWare in wares
			addWare(iWare)

	/** Remove given ware from the stock. */
	function removeWare(ware w)
		for iWare in wares
			if iWare.hasSameType(w)
				// Check and adjust ware:
				if iWare.count <= w.count
					wares.remove(iWare)
				else
					wares.replace(iWare, iWare.changedCopy(-w.count))

	/** Remove given wares from the stock. */
	function removeWares(ArrayList<ware> wares)
		for iWare in wares
			removeWare(iWare)

	/** Returns if the stock has any wares of given target stock. */
	function containsAny(Stock targetStock) returns bool
		for iWare in wares
			if targetStock.getWareCount(iWare.wareType) > 0
				return true
		return false