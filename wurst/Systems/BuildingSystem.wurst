/*-------------------------------------------------------------
// Version number:
1.0.0

// Description:
Allows buildings to require wares as building cost before the building process can be started. Also allows for worker and building type dependant build speed.
Uses the upgrade mechanism from a general building ground to have a fully controllable building progress.
Dynamically adjustes the building health stats based on the building progress.

// Changelog:
- 1.0.0:
Initial version.
-------------------------------------------------------------*/
package BuildingSystem
import RegisterEvents
import InstantDummyCaster
import ClosureTimers
import Icons
import ConstantDataSystem
import MultiboardPrioritySystem
import UtilityFunctions
import Stock
import StorageSystem
import Unit_TownHall
import OrderSystem
import UnitMap
import UnitIndexer
import LinkedList
import UnitTest


// --------------------
// Data code
// --------------------

let BUILDING_ADJUSTMENT_RATE = 0.1
let BUILDING_START_HP_PERCENTAGE = 0.1  // Has to be smaller than 1 and bigger than 0
let MAX_AUTO_ORDER_RANGE = 1024.
let MAX_NEAR_BY_RANGE = 256.
let BUILDING_GROUND_UNIT_ID = UnitIdsCustom.buildingGround
let BUILD_PROGRESS_ICON_PATH = Icons.bTNEngineeringUpgrade
let BUILD_TIME_LEFT_ICON_PATH = Icons.bTNStatUp
let WORKERS_ICON_PATH = Icons.bTNBash

function getRequiredWares(int buildingUnitId) returns LinkedList<ware>
	var wares = new LinkedList<ware>()
	switch buildingUnitId
		case UnitIdsCustom.farm
			wares.add(ware(WareType.WOOD, 4))
		case UnitIdsCustom.townHall
			wares.add(ware(WareType.WOOD, 4))
			wares.add(ware(WareType.STONE, 3))
	return wares

function getUnitWorkPower(int workerUnitId, int buildingUnitId) returns real
	switch workerUnitId
		case UnitIdsCustom.peasant
			switch buildingUnitId
				case UnitIdsCustom.farm
					return 0.05
				case UnitIdsCustom.townHall
					return 0.01
	return 0.

function getBuildingScaling(int buildingUnitId) returns real
	switch buildingUnitId
		case UnitIdsCustom.farm
			return 1.
		case UnitIdsCustom.townHall
			return UnitData_Townhall.scalingValue
	return 0.


// --------------------
// Functional code
// --------------------

let BUILDING_SITE_MAP = new IterableUnitHashMap<BuildingSite>(null)
let WORKER_MAP = new UnitHashMap<BuildingSite>(null)

class BuildingSite extends Stock
	private real fullHP
	private int workerCount
	private real workProgress
	private real workPower
	private int upgradeProgress

	construct(unit building, real fullHP, LinkedList<ware> requiredWares)
		super(requiredWares)
		user = building
		this.fullHP = fullHP
		workerCount = 0
		workProgress = 0.
		workPower = 0.
		upgradeProgress = 1

	function getWorkProgress() returns real
		return workProgress

	function getWorkPower() returns real
		return workPower

	function getWorkerCount() returns int
		return workerCount

	function addWorker(unit worker)
		if WORKER_MAP.has(worker) == false
			WORKER_MAP.put(worker, this)
			workPower += getUnitWorkPower(worker.getUnitId(), user.getUnitId())
			workerCount += 1
			InstantDummyCaster.castTarget(null, AbilityIdsCustom.addBuildingBuff, 1, AbilityIdsCustom.addBuildingBuff.getAbilityOrder(), worker)
			doAfter(MIN_TRIGGER_SLEEP_TIME, () -> SetUnitAnimation(worker, "work"))
		else
			Log.error("ERROR: Can't add worker to this building site")

	function removeWorker(unit worker)
		if workerCount <= 0
			Log.error("ERROR: Can not remove more workers from building site (" + user.getName() + ")")
		else if WORKER_MAP.get(worker) == this
			WORKER_MAP.remove(worker)
			workPower -= getUnitWorkPower(worker.getUnitId(), user.getUnitId())
			workerCount -= 1
			ResetUnitAnimation(worker)
			worker.removeAbility(BuffIdsCustom.building)
		else
			Log.error("ERROR: Can't remove worker from this building site")

	function adjustProgress() returns bool
		if workPower > 0.
			// Adjust work progress:
			workProgress += workPower * BUILDING_ADJUSTMENT_RATE
			if workProgress >= 1.
				// Finish construction:
				UnitSetUpgradeProgress(user, 100)
				return true
			else
				// Recalculate values:
				user.setMaxHP(max(1, (fullHP * (workProgress * (1 - BUILDING_START_HP_PERCENTAGE) + BUILDING_START_HP_PERCENTAGE)).toInt()))
				user.addHP(fullHP * (1 - BUILDING_START_HP_PERCENTAGE) * workPower * BUILDING_ADJUSTMENT_RATE)
				upgradeProgress = min(max(1, (workProgress * 100.).toInt()), 99)
		// Always adjust upgrade progress so that it stays correct:
		UnitSetUpgradeProgress(user, upgradeProgress)
		return false

	function hasCarrierRequiredResources(unit carrier) returns bool
		if this.hasWares()
			var carrierStorage = carrier.getStorage()
			if carrierStorage != null and carrierStorage.containsAny(this)
				return true
		return false

	function callOverIdleWorkers(unit unconditionedOrderWorker)
		// Order nearby idle workers to build on building site:
		ENUM_GROUP.enumUnitsInRange(user.getPos(), MAX_AUTO_ORDER_RANGE, null)
		let owner = user.getOwner()
		for worker from ENUM_GROUP
			if user.getUnitId().isValidWorkerType(worker.getUnitId()) and worker.getOwner() == owner and (worker.getOrderSource() == null or worker == unconditionedOrderWorker)
				worker.issueTargetAbilityOrder(AbilityIdsCustom.build, user, true)

	function callOverIdleWareCarriers()
		// Order nearby idle workers to build on building site:
		ENUM_GROUP.enumUnitsInRange(user.getPos(), MAX_NEAR_BY_RANGE, null)
		let owner = user.getOwner()
		for carrier from ENUM_GROUP
			if carrier.getOwner() == owner and carrier.getOrderSource() == null and hasCarrierRequiredResources(carrier)
				carrier.issueTargetAbilityOrder(AbilityIdsCustom.transferWares, user, true)

	function transferWares(Storage source)
		var leftRequiredWares = new LinkedList<ware>()
		// Look through all required wares:
		for i = 0 to getAmountOfWareTypes() - 1
			var ware = getWare(i)
			var count = source.getWareCount(ware.wareType)
			if count < ware.count
				// Note down still missing wares:
				leftRequiredWares.add(ware(ware.wareType, ware.count - count))
			else
				// Limit taken wares to required amount:
				count = ware.count
			if count > 0
				// Remove taken wares from source:
				source.removeWare(ware(ware.wareType, count))
		// Update still required wares:
		destroy wares
		wares = leftRequiredWares


function unit.addBuildingSite()
	if BUILDING_SITE_MAP.has(this) == false
		let targetUnitId = this.getUnitId()
		let fullHP = this.getMaxHP()
		let buildingGround = this.replace(BUILDING_GROUND_UNIT_ID)
		IssueImmediateOrderById(buildingGround, targetUnitId.getUnitTypeId())  // Upgrade building ground to target building type
		buildingGround.setScale(getBuildingScaling(targetUnitId))
		buildingGround.setMaxHP(max(1, (fullHP * BUILDING_START_HP_PERCENTAGE).toInt()))
		let buildingSite = new BuildingSite(buildingGround, fullHP, getRequiredWares(targetUnitId))
		BUILDING_SITE_MAP.put(buildingGround, buildingSite)
		if buildingSite.hasWares() == false
			buildingSite.callOverIdleWorkers(null)
		else
			buildingSite.callOverIdleWareCarriers()

function unit.removeBuildingSite()
	let buildingSite = BUILDING_SITE_MAP.tryRemove(this)
	if buildingSite != null
		destroy buildingSite

function findNextBuildingSite_GetFilter() returns filterfunc
	return Filter() ->
		var conditionsFulfilled = false
		let buildingSite = GetFilterUnit().getBuildingSite()
		// Only allow building sites that don't have any required wares left:
		if buildingSite != null and buildingSite.hasWares() == false
			conditionsFulfilled = true
		return conditionsFulfilled
/** Returns next valid building site unit at the position for given player. */
public function vec2.findNextBuildingSite(player owner) returns unit
	var filter = findNextBuildingSite_GetFilter()
	let building = this.getNearestUnit(MAX_AUTO_ORDER_RANGE, filter, owner)
	filter.destr()
	return building
/** Returns next valid building site unit for the unit. */
public function unit.findNextBuildingSite() returns unit
	let owner = this.getOwner()
	let pos = this.getPos()
	let workerUnitId = this.getUnitId()
	var filter = findNextBuildingSite_GetFilter()
	// Set init values:
	var bestDistanceSq = REAL_MAX
	unit nearestBuilding = null
	// Filter out invalid units in range:
	ENUM_GROUP.enumUnitsInRange(pos, MAX_AUTO_ORDER_RANGE, filter)
	// Find nearest valid unit:
	for target from ENUM_GROUP
		if target.getOwner() == owner and target.getUnitId().isValidWorkerType(workerUnitId)
			let distanceSq = pos.distanceToSq(target.getPos())
			if distanceSq < bestDistanceSq
				bestDistanceSq = distanceSq
				nearestBuilding = target
	filter.destr()
	return nearestBuilding

/** Returns the building site of given unit. */
public function unit.getBuildingSite() returns BuildingSite
	return BUILDING_SITE_MAP.tryGet(this)

/** Returns the building site of given worker. */
public function unit.getBuildingSiteOfWorker() returns BuildingSite
	return WORKER_MAP.tryGet(this)

/** Returns the count of all building sites. */
public function getBuildingSiteCount() returns int
	return BUILDING_SITE_MAP.getValueCount()

/** Returns the count of all workers. */
public function getWorkerCount() returns int
	return WORKER_MAP.getValueCount()

/** Returns if the given worker type can work on given building type */
public function int.isValidWorkerType(int workerUnitId) returns bool
	return getUnitWorkPower(workerUnitId, this) > 0.

/** Sets system relevant infos for given object in target multiboard. */
public function multiboard.setObjectInfoMultiboard(BuildingSite bs) returns bool
	this.addMultiboardLine("Building site:", HEADLINE_ICON_PATH)
	this.addMultiboardLine("Build progress: " + (bs.getWorkProgress() * 100.).toInt().toString() + "%", BUILD_PROGRESS_ICON_PATH)
	let workPower = bs.getWorkPower()
	if workPower > 0.
		this.addMultiboardLine("Build time left: " + ((1 - bs.getWorkProgress()) / workPower).toInt().toString() + "s", BUILD_TIME_LEFT_ICON_PATH)
		this.addMultiboardLine("Workers: " + bs.getWorkerCount().toString(), WORKERS_ICON_PATH)
	let amountOfWareTypes = bs.getAmountOfWareTypes()
	if amountOfWareTypes > 0
		this.addMultiboardLine("Required wares:", HEADLINE_ICON_PATH)
		for i = 0 to (amountOfWareTypes - 1)
			var ware = bs.getWare(i)
			this.addMultiboardLine(ware.count.toString() + " " + ware.toString(true), ware.getIconPath())
	return true

init
	// Remove resource from every appropriate removed unit:
	onUnitDeindex() ->
		getIndexingUnit().removeBuildingSite()
	// Adjust progress of all building sites:
	let finishedBuildings = CreateGroup()
	doPeriodically(BUILDING_ADJUSTMENT_RATE) cb ->
		for building in BUILDING_SITE_MAP
			if building != null and BUILDING_SITE_MAP.get(building).adjustProgress()
				finishedBuildings.addUnit(building)
		// Remove finished building sites:
		for building from finishedBuildings
			building.removeBuildingSite()
	// Register construction starts:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_CONSTRUCT_START) ->
		let building = GetConstructingStructure()
		if getBuildingScaling(building.getUnitId()) > 0.
			doAfter(MIN_TRIGGER_SLEEP_TIME, () -> building.addBuildingSite())
	// Register construction abortions:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_UPGRADE_CANCEL) ->
		let building = GetTriggerUnit()
		building.removeBuildingSite()
		building.kill()
		building.remove()


// --------------------
// Test code
// --------------------

unit testBuildingSystem_Build_building = null
@Test public function testBuildingSystem_Build()
	let testName = "testBuildingSystem_Build"
	string usedTestName
	// Order to build:
	let unitA = createUnit(Player(0), UnitIdsCustom.peasant, vec2(0, 0), angle(0))
	let storageA = unitA.getStorage()
	usedTestName = useTestName(testName)
	if storageA == null
		testFail(usedTestName, "Test failed: Couldn't get Storage of unitA")
	storageA.addWare(ware(WareType.WOOD, 5))
	var workerCount = getWorkerCount()
	var buildingSiteCount = getBuildingSiteCount()
	unitA.issuePointOrderById(UnitIdsCustom.farm, vec2(0, 0))
	testBuildingSystem_Build_building = null
	// FIXME: testDebug doesn't seem to work
	testDebug(useTestName(testName), "test")  // DEBUG:
	testDebug(useTestName(testName), 1)  // DEBUG:
	// Check worker and building site:
	doAfter(MIN_ACTION_SLEEP_TIME) () ->
		// Check unit mappings:
		(getWorkerCount() - workerCount).assertEquals(1)
		(getBuildingSiteCount() - buildingSiteCount).assertEquals(1)
		WORKER_MAP.has(unitA).assertTrue()
		let a = unitA.getBuildingSiteOfWorker()
		usedTestName = useTestName(testName)
		if a == null
			testFail(usedTestName, "Test failed: Couldn't get BuildingSite of worker unitA")
		testBuildingSystem_Build_building = a.user
		usedTestName = useTestName(testName)
		if testBuildingSystem_Build_building == null
			testFail(usedTestName, "Test failed: Couldn't get unit of BuildingSite a")
		usedTestName = useTestName(testName)
		if testBuildingSystem_Build_building.getBuildingSite() != a
			testFail(usedTestName, "Test failed: Couldn't get BuildingSite via function getBuildingSite")
		usedTestName = useTestName(testName)
		if unitA.findNextBuildingSite() != testBuildingSystem_Build_building
			testFail(usedTestName, "Test failed: Couldn't find BuildingSite via function findNextBuildingSite")
		// Check building site status:
		a.getWorkProgress().assertEquals(0.)
		a.getWorkPower().assertEquals(0.05)
		a.getWorkerCount().assertEquals(1)
		a.hasWares().assertFalse()
	// Simulate construction abortion:
	doAfter(2 * MIN_ACTION_SLEEP_TIME) () ->
		usedTestName = useTestName(testName)
		if testBuildingSystem_Build_building == null
			testFail(usedTestName, "Test failed: unitB is null")
		// FIXME: removeWorker in cancelCb has invalid object -> maybe problem of "simulation" (EVENT_PLAYER_UNIT_UPGRADE_CANCEL might cause workers to stop beforehand) or with timing
		testBuildingSystem_Build_building.removeBuildingSite()
		testBuildingSystem_Build_building.kill()
		testBuildingSystem_Build_building.remove()
	// Remove test units:
	doAfter(3 * MIN_ACTION_SLEEP_TIME) () ->
		unitA.kill()
		unitA.remove()