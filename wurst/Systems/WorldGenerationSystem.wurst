/*-------------------------------------------------------------
// Version number:
1.0.0

// Description:
Handles world map generation like terrain deformation and unit placement.

// Changelog:
- 1.0.0:
Initial version.
-------------------------------------------------------------*/
package WorldGenerationSystem
import TerrainUtils
import Interpolation
import Array2D
import ConstantData
import UtilityFunctions
import Entity
import ResourceSystem
import LoadStatusSystem
import ComputationControl
import Destructable_Spruce


// --------------------
// Data code
// --------------------

// Terrain:
let TILES_X = 104
let TILES_Y = 104
let TERRAIN_HEIGHT_INIT = 0.
let TERRAIN_HEIGHT_MIN = -64.  // Min HEIGHT_DEEP_WATER_MIN
let TERRAIN_HEIGHT_MAX = HEIGHT_LAND_MIN + 786.  // Max HEIGHT_LAND_MAX
let ORIGIN_VEC = vec2(-6656., -7168.)  // Left, bottom point from which the terrain generation starts towards right, top point

// Nature:
let NATURE_PLAYER = Player(PLAYER_NEUTRAL_PASSIVE)
let TREE_COVERAGE_PERCENTAGE_MIN = 0.2  // Noise values below that value will never spawn trees
let TREE_COVERAGE_PERCENTAGE_MAX = 1.2  // A higher value means a lower probablity to spawn trees


// --------------------
// Functional code
// --------------------

Array2DReal heightMap

public function generateTerrain()
    // Adjust the height for each tile:
    heightMap = generatePerlinNoise(TILES_X, TILES_Y, 7, 0.6, "Cosine")
    forceComputationBreak()
    newInitSubStatus("Adjust terrain")
    for	x = 0 to TILES_X - 1
        setInitStepStatus(x + 1, TILES_X)
        for	y = 0 to TILES_Y - 1
            let z = linear(TERRAIN_HEIGHT_MIN, TERRAIN_HEIGHT_MAX, heightMap.get(x, y))
            heightMap.set(x, y, z)
            let pos = ORIGIN_VEC.add(x * TILE_DISTANCE, y * TILE_DISTANCE)
            pos.addTerrainHeight(z - TERRAIN_HEIGHT_INIT)  // Terrain has to have water on it before hand for it to show up
            // Assert that pathing is set to deep water beforehand
            if z >= HEIGHT_LAND_MIN
                let tile = pos.getTile()
                tile.setPathing(PATHING_TYPE_FLOATABILITY, false)
                tile.setPathing(PATHING_TYPE_WALKABILITY, true)
                tile.setPathing(PATHING_TYPE_BUILDABILITY, true)
            else if z >= HEIGHT_SHALLOW_WATER_MIN
                let tile = pos.getTile()
                tile.setPathing(PATHING_TYPE_WALKABILITY, true)
                tile.setPathing(PATHING_TYPE_BUILDABILITY, false)
            computationCost += 0.821
        checkForComputationBreak()

public function generatePlants()
    // Have 1 or 0 tree per tile:
    let plantMap = generatePerlinNoise(TILES_X, TILES_Y, 5, 0.6, "Cosine")
    forceComputationBreak()
    newInitSubStatus("Add plants")
    for	x = 0 to TILES_X - 1  // DEBUG:
        plantMap.set(x, TILES_Y - 4, 0.42)  // DEBUG:
        plantMap.set(x, TILES_Y - 2, 0.12)  // DEBUG:
    forceComputationBreak()  // DEBUG:
    for	x = 0 to TILES_X - 1
        // setInitStepStatus(x + 1, TILES_X)  // DEBUG:
        for	y = 0 to TILES_Y - 1
            // FIXME: a lot is just 1 -> maybe a problem with Array -> only if heightMap isn't destroyed (offset only by 10816) -> should be fixed with Array index fix -> still trees everywhere
            // FIXME: only entries with 0, 1, 2 for y have values != 1 -> Problem doesn't seem to be the array index -> Try to create a unit test to find the cause for the problem
            if plantMap.get(x, y) <= 0.99  // DEBUG:
                Log.debug(plantMap.get(x, y).toString() + " " + x.toString() + "/" + y.toString() + " " + plantMap.DEBUG_getArrayIndex(x, y).toString())  // DEBUG:
            if plantMap.get(x, y) >= GetRandomReal(TREE_COVERAGE_PERCENTAGE_MIN, TREE_COVERAGE_PERCENTAGE_MAX)  // Noise value is the probability, thus compare to random value
                let pos = ORIGIN_VEC + vec2(x + GetRandomReal(-0.5, 0.5), y + GetRandomReal(-0.5, 0.5)) * TILE_DISTANCE
                // createUnit(NATURE_PLAYER, UnitIdsCustom.Trees.beech.getUnitTypeId(), pos, getRandomAngle())  // DEBUG:
                // entity(null, createDestructable(DestructableIdsCustom.Trees.spruce, pos, getRandomAngle(), GetRandomReal(0.8, 1.2), GetRandomInt(0, 9))).tryAddResouce()  // DEBUG:
                entity(null, createDestructable(DestructableIdsCustom.Trees.spruce, pos, getRandomAngle(), GetRandomReal(DestructableData_Spruce.minScale, DestructableData_Spruce.maxScale), getRandomVariation(DestructableData_Spruce.variations))).tryAddResouce()
            computationCost += 0.224
        checkForComputationBreak()
    destroy plantMap