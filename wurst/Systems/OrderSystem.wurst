/*-------------------------------------------------------------
// Version number:
1.01

// Description:
TODO

// Changelog:
- 1.01:
Initial version.
-------------------------------------------------------------*/
package OrderSystem
import RegisterEvents
import HashMap
import OnUnitEnterLeave
import ClosureTimers
import UtilityFunctions
import ConstantDataSystem
import initlater ResourceSystem


// --------------------
// Functional code
// --------------------

let ORDER_SOURCE_MAP = new HashMap<unit, OrderSource>  // TODO: maybe make a general unit to class hash map system with corresponding utility functions
let ORDER_TARGET_MAP = new HashMap<unit, OrderTarget>  // TODO: maybe make a general unit to class hash map system with corresponding utility functions

class OrderTarget
	private unit target
	private group sources

	construct(unit target, unit source)
		sources = CreateGroup()
		sources.addUnit(source)
		this.target = target

	ondestroy
		// Find new targets for sources:
		for u from sources
			u.findNewTarget(target)
		sources.destr()

	function addSource(unit source)
		if sources.contains(source) == false
			sources.addUnit(source)

	function removeSource(unit source)
		if sources.contains(source)
			sources.removeUnit(source)


// TODO: maybe make derivates of this class with different target types etc.
class OrderSource
	private unit source
	private int orderId
	private unit target

	construct(unit source, int orderId, unit target)
		this.source = source
		this.target = null
		newOrder(orderId, target)

	function newOrder(int newOrderId, unit newTarget)
		orderId = newOrderId
		if target != newTarget
			// Remove old order target:
			if target != null
				cancel()
			// Set new order target:
			target = newTarget
			if ORDER_TARGET_MAP.has(newTarget)
				ORDER_TARGET_MAP.get(newTarget).addSource(source)
			else
				ORDER_TARGET_MAP.put(newTarget, new OrderTarget(newTarget, source))

	function cancel()
		ORDER_TARGET_MAP.get(target).removeSource(source)


function unit.findNewTarget(unit oldTarget)
	// TEST: check that a resource isn't removed before it is used here
	if oldTarget.getResource() != null
		doAfter(MIN_TRIGGER_SLEEP_TIME, () -> this.issueTargetAbilityOrder(AbilityIdsCustom.harvest, this.findNextResource(), true))

function unit.setOrder(int orderId, unit target)
	if ORDER_SOURCE_MAP.has(this)
		// Adjust order source:
		ORDER_SOURCE_MAP.get(this).newOrder(orderId, target)
	else
		// Add new order source:
		ORDER_SOURCE_MAP.put(this, new OrderSource(this, orderId, target))

/** Clear unit from it's current order. */
public function unit.removeSourceUnit()
	if ORDER_SOURCE_MAP.has(this)
		destroy ORDER_SOURCE_MAP.get(this)
		ORDER_SOURCE_MAP.remove(this)

/** Clear unit as order traget. */
public function unit.removeTargetUnit()
	if ORDER_TARGET_MAP.has(this)
		destroy ORDER_TARGET_MAP.get(this)
		ORDER_TARGET_MAP.remove(this)

init
	// Remove order source and target from every appropriate removed unit:
	onLeave() ->
		getEnterLeaveUnit().removeSourceUnit()
		getEnterLeaveUnit().removeTargetUnit()
	// Register issued orders:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER) ->
		GetOrderedUnit().setOrder(GetIssuedOrderId(), GetOrderTargetUnit())