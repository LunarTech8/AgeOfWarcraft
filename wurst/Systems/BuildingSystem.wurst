/*-------------------------------------------------------------
// Version number:
1.01

// Description:
TODO

// Changelog:
- 1.01:
Initial version.
-------------------------------------------------------------*/
package BuildingSystem
import RegisterEvents
import InstantDummyCaster
import OnUnitEnterLeave
import ClosureTimers
import LinkedList
import HashMap
import Icons
import Orders
import Stock
import ConstantDataSystem
import MultiboardPrioritySystem
import UtilityFunctions
import Unit_TownHall


// --------------------
// Data code
// --------------------

let infoMsgTime = 2.
let buildAdjustmentRate = 0.1
let buildStartHPPercentage = 0.1  // Has to be smaller than 1 and bigger than 0
let maxAutoOrderRange = 1024.
let buildProgressIconPath = Icons.bTNEngineeringUpgrade
let buildTimeLeftIconPath = Icons.bTNStatUp
let workersIconPath = Icons.bTNBash

function getRequiredWares(int buildingUnitId) returns LinkedList<ware>
	var wares = new LinkedList<ware>()
	switch buildingUnitId
		case UnitIdsCustom.farm
			wares.add(ware(WareType.Wood, 4))
		case UnitIdsCustom.townHall
			wares.add(ware(WareType.Wood, 4))
			wares.add(ware(WareType.Stone, 3))
	return wares

function getUnitWorkPower(int workerUnitId, int buildingUnitId) returns real
	switch workerUnitId
		case UnitIdsCustom.peasant
			switch buildingUnitId
				case UnitIdsCustom.farm
					return 0.05
				case UnitIdsCustom.townHall
					return 0.01
	return 0.

function getBuildingScaling(int buildingUnitId) returns real
	switch buildingUnitId
		case UnitIdsCustom.farm
			return 1.
		case UnitIdsCustom.townHall
			return UnitData_Townhall.scalingValue
	return 0.

	
// --------------------
// Functional code
// --------------------

let buildingSiteMap = new IterableMap<unit, BuildingSite>  // TODO: maybe make a general unit to class hash map system with corresponding utility functions
let workerMap = new HashMap<unit, BuildingSite>  // TODO: maybe make a general unit to class hash map system with corresponding utility functions

class BuildingSite extends Stock
	private unit building
	private real fullHP
	private group workers
	private real workProgress
	private real workPower
	private int upgradeProgress

	construct(unit building, real fullHP, LinkedList<ware> requiredWares)
		super(requiredWares)
		this.building = building
		this.fullHP = fullHP
		workers = CreateGroup()
		workProgress = 0.
		workPower = 0.
		upgradeProgress = 1

	ondestroy
		for worker in workers
			removeWorker(worker)
			doAfter(minTriggerSleepTime, () -> worker.issueTargetAbilityOrder(AbilityIdsCustom.build, findNextBuildingSite(worker.getPos(), worker.getOwner()), true))
		workers.destr()

	function hasNoRequiredWaresLeft() returns bool
		return wares.isEmpty()

	function getWorkProgress() returns real
		return workProgress	

	function getWorkPower() returns real
		return workPower

	function getWorkerCount() returns int
		return workers.size()
	
	function addWorker(unit worker)
		if workerMap.has(worker) == false and workers.contains(worker) == false
			workerMap.put(worker, this)
			workPower += getUnitWorkPower(getUnitId(worker), getUnitId(building))
			workers.addUnit(worker)
			InstantDummyCaster.castTarget(null, AbilityIdsCustom.addBuildingBuff, 1, getAbilityOrder(AbilityIdsCustom.addBuildingBuff), worker)
			doAfter(minTriggerSleepTime, () -> SetUnitAnimation(worker, "work"))
		else
			Log.error("ERROR: can't add worker to this building site")

	function removeWorker(unit worker)
		if workerMap.get(worker) == this and workers.contains(worker)
			workerMap.remove(worker)
			workPower -= getUnitWorkPower(getUnitId(worker), getUnitId(building))
			workers.removeUnit(worker)
			ResetUnitAnimation(worker)
			worker.removeAbility(BuffIdsCustom.building)
		else
			Log.error("ERROR: can't remove worker from this building site")
	
	function adjustProgress() returns bool
		if workPower > 0.
			// Adjust work progress:
			workProgress += workPower * buildAdjustmentRate
			if workProgress >= 1.
				// Finish construction:
				UnitSetUpgradeProgress(building, 100)
				return true
			else
				// Recalculate values:
				building.setMaxHP(max(1, (fullHP * (workProgress * (1 - buildStartHPPercentage) + buildStartHPPercentage)).toInt()))
				building.addHP(fullHP * (1 - buildStartHPPercentage) * workPower * buildAdjustmentRate)
				upgradeProgress = min(max(1, (workProgress * 100.).toInt()), 99)
		// Always adjust upgrade progress so that it stays correct:
		UnitSetUpgradeProgress(building, upgradeProgress)
		return false


function addBuildingSite(unit building)
	if buildingSiteMap.has(building) == false
		let targetUnitId = getUnitId(building)
		let fullHP = building.getMaxHP()
		let buildingGround = building.replace(UnitIdsCustom.buildingGround)
		IssueImmediateOrderById(buildingGround, getUnitTypeId(targetUnitId))  // Upgrade building ground to target building type
		buildingGround.setScale(getBuildingScaling(targetUnitId))
		buildingGround.setMaxHP(max(1, (fullHP * buildStartHPPercentage).toInt()))
		let buildingSite = new BuildingSite(buildingGround, fullHP, getRequiredWares(targetUnitId))
		buildingSiteMap.put(buildingGround, buildingSite)
		if buildingSite.hasNoRequiredWaresLeft()
			// Order nearby idle workers to build on building site:
			ENUM_GROUP.enumUnitsInRange(buildingGround.getPos(), maxAutoOrderRange, null)
			let owner = buildingGround.getOwner()
			for worker from ENUM_GROUP
				if getUnitWorkPower(getUnitId(worker), targetUnitId) > 0. and worker.getOwner() == owner and (worker.getCurrentOrder() == 0 or IsUnitSelected(worker, owner)) and worker.hasAbility(BuffIdsCustom.building) == false
					worker.issueTargetAbilityOrder(AbilityIdsCustom.build, buildingGround, true)

function removeBuildingSite(unit target)
	if buildingSiteMap.has(target)
		destroy buildingSiteMap.get(target)
		buildingSiteMap.remove(target)

function findNextBuildingSite(vec2 pos, player owner) returns unit
	var filter = Filter() ->
		var conditionsFulfilled = false
		let buildingSite = getBuildingSite(GetFilterUnit())
		// Only allow building sites that don't have any required wares left:
		if buildingSite != null and buildingSite.hasNoRequiredWaresLeft()
			conditionsFulfilled = true
		return conditionsFulfilled
	let building = getNearestUnit(pos, maxAutoOrderRange, filter, owner)
	filter.destr()
	return building

/** Returns harvest validity: 1=Valid 2=InvalidWorker 3=InvalidTarget 4=WaresNotAvailable 5=WorkerAlreadyBuilding */
function getBuildValidity(unit worker, unit target) returns int
	// Check if source and target are valid:
	if getUnitWorkPower(getUnitId(worker), getUnitId(target)) <= 0.
		return 2
	var buildingSite = getBuildingSite(target)
	if buildingSite == null
		return 3
	// Check if required wares are available:
	if buildingSite.hasNoRequiredWaresLeft() == false
		return 4
	// Check if worker is already building:
	if workerMap.has(worker)
		return 5
	else
		return 1
		
/** If worker is building stop him. */
function stopBuilding(unit worker)
	if workerMap.has(worker)
		workerMap.get(worker).removeWorker(worker)

/** Returns the building site of given unit. */
public function getBuildingSite(unit target) returns BuildingSite
	if buildingSiteMap.has(target)
		return buildingSiteMap.get(target)
	else
		return null
		
/** Sets system relevant infos for given object in target multiboard. */
public function setObjectInfoMultiboard(multiboard m, BuildingSite bs) returns bool
	addMultiboardLine(m, "Building site:", headlineIconPath)
	addMultiboardLine(m, "Build progress: " + (bs.getWorkProgress() * 100.).toInt().toString() + "%", buildProgressIconPath)
	let workPower = bs.getWorkPower()
	if workPower > 0.
		addMultiboardLine(m, "Build time left: " + ((1 - bs.getWorkProgress()) / workPower).toInt().toString() + "s", buildTimeLeftIconPath)
	addMultiboardLine(m, "Workers: " + bs.getWorkerCount().toString(), workersIconPath)
	let amountOfWareTypes = bs.getAmountOfWareTypes()
	if amountOfWareTypes > 0
		addMultiboardLine(m, "Required wares:", headlineIconPath)
		for i = 0 to (amountOfWareTypes - 1)
			var ware = bs.getWare(i)
			addMultiboardLine(m, ware.count.toString() + " " + ware.toString(true), ware.getIconPath())
	return true
	
init
	// Remove resource from every appropriate removed unit:
	onLeave() -> 
		removeBuildingSite(getEnterLeaveUnit())
	// Adjust progress of all building sites:
	let finishedBuildings = CreateGroup()
	doPeriodically(buildAdjustmentRate) cb ->
		for building in buildingSiteMap
			if buildingSiteMap.get(building).adjustProgress()
				finishedBuildings.addUnit(building)
		// Remove finished building sites:
		for building from finishedBuildings
			removeBuildingSite(building)
	// Register construction starts:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_CONSTRUCT_START) ->
		let building = GetConstructingStructure()
		if getBuildingScaling(getUnitId(building)) > 0.
			doAfter(minTriggerSleepTime, () -> addBuildingSite(building))
	// Register construction abortions:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_UPGRADE_CANCEL) ->
		let building = GetTriggerUnit()
		removeBuildingSite(building)
		building.kill()
		building.remove()
	// Register build spell:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CAST) ->
		if GetSpellAbilityId() == AbilityIdsCustom.build
			let worker = GetTriggerUnit()
			let target = GetSpellTargetUnit()
			let validity = getBuildValidity(worker, target)
			if validity != 1
				// React on invalid command:
				let owner = worker.getOwner()
				if IsUnitSelected(worker, owner)
					switch validity
						case 2  // InvalidWorker
							printTimedToPlayer("Invalid: Worker can't build at target building site type", infoMsgTime, owner)
						case 3  // InvalidTarget
							printTimedToPlayer("Invalid: Build target is no building site", infoMsgTime, owner)
						case 4  // WaresNotAvailable
							printTimedToPlayer("Invalid: Not all required wares are available", infoMsgTime, owner)
						case 5  // WorkerAlreadyBuilding
							printTimedToPlayer("Invalid: Worker is already building", infoMsgTime, owner)
				worker.abortOrder()
			else
				getBuildingSite(target).addWorker(worker)
	// Register building stops:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_ORDER, () -> stopBuilding(GetTriggerUnit()))
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER, () -> stopBuilding(GetTriggerUnit()))
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER, () -> stopBuilding(GetTriggerUnit()))
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_UNIT_ORDER, () -> stopBuilding(GetTriggerUnit()))
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ATTACKED, () -> stopBuilding(GetTriggerUnit()))
	// Register smart order:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER) ->
		let worker = GetTriggerUnit()
		let target = GetOrderTargetUnit()
		if GetIssuedOrderId() == OrderIds.smart and getBuildValidity(worker, target) == 1
			worker.issueTargetAbilityOrder(AbilityIdsCustom.build, target, true)