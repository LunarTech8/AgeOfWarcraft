/*-------------------------------------------------------------
// Version number:
1.01

// Description:
TODO

// Changelog:
- 1.01:
Initial version.
-------------------------------------------------------------*/
package OrderSystem
import RegisterEvents
import HashMap
import OnUnitEnterLeave
import ClosureTimers
import Orders
import UtilityFunctions
import ConstantDataSystem
import ResourceSystem
import BuildingSystem
import LinkedList
import TimerUtils


// --------------------
// Data code
// --------------------

enum TargetType
	OTHER
	RESOURCE
	BUILDING_SITE


// --------------------
// Functional code
// --------------------

let ORDER_SOURCE_MAP = new HashMap<unit, OrderSource>  // TODO: maybe make a general unit to class hash map system with corresponding utility functions
let ORDER_TARGET_MAP = new HashMap<unit, OrderTarget>  // TODO: maybe make a general unit to class hash map system with corresponding utility functions

interface CallbackSimple
	function call()

class OrderTarget
	private unit target
	private LinkedList<OrderSource> sources
	private TargetType targetType

	construct(unit target, OrderSource source)
		sources = new LinkedList<OrderSource>()
		sources.add(source)
		this.target = target
		if target.getResource() != null
			targetType = TargetType.RESOURCE
		else if target.getBuildingSite() != null
			targetType = TargetType.BUILDING_SITE
		else
			targetType = TargetType.OTHER

	ondestroy
		// Find new targets for sources:
		for s in sources
			s.source.findNewTarget(targetType)
		sources.clear()
		destroy sources

	function addSource(OrderSource source)
		if sources.has(source) == false
			sources.add(source)
		else
			Log.error("ERROR: source already has that target")

	function removeSource(OrderSource source)
		if sources.has(source)
			sources.remove(source)
		else
			Log.error("ERROR: source does not have that target")

public class OrderAction
	private timer t
	private CallbackSimple cancelCb
	private CallbackSimple finishCb

	construct(real duration, CallbackSimple cancelCb, CallbackSimple finishCb)
		this.cancelCb = cancelCb
		this.finishCb = finishCb
		t = getTimer()
		t.setData(this castTo int)
		t.start(duration, () -> finish())

	ondestroy
		if t != null
			t.release()
		if cancelCb != null
			destroy cancelCb
		if finishCb != null
			destroy finishCb

	private static function finish()
		timer t = GetExpiredTimer()
		thistype cb = t.getData() castTo thistype
		if cb.finishCb != null
			cb.finishCb.call()
		cb.t = null
		t.release()

	function cancel()
		if cancelCb != null
			cancelCb.call()
		destroy this

class OrderSource
	protected unit source
	protected int orderId
	private OrderAction orderAction = null

	construct(unit source, int orderId, OrderAction orderAction)
		this.source = source
		this.orderId = orderId
		this.orderAction = orderAction

	ondestroy
		if orderAction != null
			orderAction.cancel()

class OrderSourceU extends OrderSource
	protected unit target

	construct(unit source, int orderId, unit target, OrderAction orderAction)
		super(source, orderId, orderAction)
		this.target = target
		if ORDER_TARGET_MAP.has(target)
			ORDER_TARGET_MAP.get(target).addSource(this)
		else
			ORDER_TARGET_MAP.put(target, new OrderTarget(target, this))

	ondestroy
		if ORDER_TARGET_MAP.has(target)
			ORDER_TARGET_MAP.get(target).removeSource(this)

class OrderSourceD extends OrderSource
	protected destructable target

	construct(unit source, int orderId, destructable target, OrderAction orderAction)
		super(source, orderId, orderAction)
		this.target = target

class OrderSourceI extends OrderSource
	protected item target

	construct(unit source, int orderId, item target, OrderAction orderAction)
		super(source, orderId, orderAction)
		this.target = target

class OrderSourceV extends OrderSource
	protected vec2 target

	construct(unit source, int orderId, vec2 target, OrderAction orderAction)
		super(source, orderId, orderAction)
		this.target = target


function unit.findNewTarget(TargetType targetType)
	// Find new order based on target type:
	if targetType == TargetType.RESOURCE
		doAfter(MIN_TRIGGER_SLEEP_TIME, () -> this.issueTargetAbilityOrder(AbilityIdsCustom.harvest, this.findNextResource(), true))
	else if targetType == TargetType.BUILDING_SITE
		doAfter(MIN_TRIGGER_SLEEP_TIME, () -> this.issueTargetAbilityOrder(AbilityIdsCustom.build, this.findNextBuildingSite(), true))

function unit.setOrder(OrderSource order)
	// Remove old order:
	if ORDER_SOURCE_MAP.has(this)
		destroy ORDER_SOURCE_MAP.get(this)
	// Add new order:
	ORDER_SOURCE_MAP.put(this, order)
/** Sets the units order to the given order Id. */
public function unit.setOrder(int orderId)
	this.setOrder(new OrderSource(this, orderId, null))
/** Sets the units order to the given order Id with given order action. */
public function unit.setOrder(int orderId, OrderAction orderAction)
	this.setOrder(new OrderSource(this, orderId, orderAction))
/** Sets the units order to the given order Id with given unit target. */
public function unit.setOrder(int orderId, unit target)
	this.setOrder(new OrderSourceU(this, orderId, target, null))
/** Sets the units order to the given order Id with given unit target and given order action. */
public function unit.setOrder(int orderId, unit target, OrderAction orderAction)
	this.setOrder(new OrderSourceU(this, orderId, target, orderAction))
/** Sets the units order to the given order Id with given destructable target. */
public function unit.setOrder(int orderId, destructable target)
	this.setOrder(new OrderSourceD(this, orderId, target, null))
/** Sets the units order to the given order Id with given destructable target and given order action. */
public function unit.setOrder(int orderId, destructable target, OrderAction orderAction)
	this.setOrder(new OrderSourceD(this, orderId, target, orderAction))
/** Sets the units order to the given order Id with given item target. */
public function unit.setOrder(int orderId, item target)
	this.setOrder(new OrderSourceI(this, orderId, target, null))
/** Sets the units order to the given order Id with given item target and given order action. */
public function unit.setOrder(int orderId, item target, OrderAction orderAction)
	this.setOrder(new OrderSourceI(this, orderId, target, orderAction))
/** Sets the units order to the given order Id with given vector target. */
public function unit.setOrder(int orderId, vec2 target)
	this.setOrder(new OrderSourceV(this, orderId, target, null))
/** Sets the units order to the given order Id with given vector target and given order action. */
public function unit.setOrder(int orderId, vec2 target, OrderAction orderAction)
	this.setOrder(new OrderSourceV(this, orderId, target, orderAction))

/** Returns if the unit has order with given parameters. */
public function unit.isOrder(int orderId, unit target) returns bool
	if ORDER_SOURCE_MAP.has(this)
		var orderSource = ORDER_SOURCE_MAP.get(this)
		return orderSource.orderId == orderId and (orderSource castTo OrderSourceU).target == target
	else
		return false

/** Clear unit as order source and target. */
public function unit.removeOrders()
	if ORDER_SOURCE_MAP.has(this)
		destroy ORDER_SOURCE_MAP.get(this)
		ORDER_SOURCE_MAP.remove(this)
	if ORDER_TARGET_MAP.has(this)
		destroy ORDER_TARGET_MAP.get(this)
		ORDER_TARGET_MAP.remove(this)

init
	// Remove order source and target from every appropriate unit:
	onLeave(() -> getEnterLeaveUnit().removeOrders())
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH, () -> GetTriggerUnit().removeOrders())
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_UPGRADE_CANCEL, () -> GetTriggerUnit().removeOrders())
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_UPGRADE_FINISH, () -> GetTriggerUnit().removeOrders())
	// Register issued orders:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER) ->
		let issuedOrderId = GetIssuedOrderId()
		// Ignore smart and callback orders:
		if issuedOrderId != OrderIds.smart and issuedOrderId != OrderIds.stunned
			let targetU = GetOrderTargetUnit()
			if targetU != null
				print("new unit order for " + GetOrderedUnit().getName() + " on " + targetU.getName() + " with order " + issuedOrderId.toString())  // DEBUG
				GetOrderedUnit().setOrder(issuedOrderId, targetU)
			else
				let targetD = GetOrderTargetDestructable()
				if targetD != null
					GetOrderedUnit().setOrder(issuedOrderId, targetD)
				else
					let targetI = GetOrderTargetItem()
					if targetI != null
						GetOrderedUnit().setOrder(issuedOrderId, targetI)
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_ORDER, () -> GetOrderedUnit().setOrder(GetIssuedOrderId()))
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER, () -> GetOrderedUnit().setOrder(GetIssuedOrderId(), vec2(GetOrderPointX(), GetOrderPointY())))