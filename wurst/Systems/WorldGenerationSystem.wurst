/*-------------------------------------------------------------
// Version number:
1.0.0

// Description:
Handles world map generation like terrain deformation and unit placement.

// Changelog:
- 1.0.0:
Initial version.
-------------------------------------------------------------*/
package WorldGenerationSystem
import TerrainUtils
import Interpolation
import Array2D
import ConstantData
import UtilityFunctions
import Entity
import ResourceSystem
import LoadStatusSystem


// --------------------
// Data code
// --------------------

// Terrain:
let TILES_X = 24
let TILES_Y = 24
// FIXME: noise blending for terrain takes too long for bigger maps (eg. 48x48) -> try adjust compCosts and add more places where it's increased
let TERRAIN_HEIGHT_INIT = 0.
let TERRAIN_HEIGHT_MIN = -64.  // Min HEIGHT_DEEP_WATER_MIN
let TERRAIN_HEIGHT_MAX = HEIGHT_LAND_MIN + 64.//1024.  // Max HEIGHT_LAND_MAX
let ORIGIN_VEC = vec2(-6656., -7168.)  // Left, bottom point from which the terrain generation starts towards right, top point

// Nature:
let NATURE_PLAYER = Player(PLAYER_NEUTRAL_PASSIVE)
let TREE_COVERAGE_PERCENTAGE_MIN = 0.25  // Noise values below that value will never spawn trees
let TREE_COVERAGE_PERCENTAGE_MAX = 1.25  // A higher value means a lower probablity to spawn trees


// --------------------
// Functional code
// --------------------

public function generateTerrain()
    var compCost = 0.
    // Adjust the height for each tile:
    let heightMap = generatePerlinNoise(TILES_X, TILES_Y, 5, 0.6, "Cosine")
    newInitSubStatus("Adjust terrain")
    for	x = 0 to TILES_X - 1
        updateInitStatus(x + 1, TILES_X)
        for	y = 0 to TILES_Y - 1
            let z = linear(TERRAIN_HEIGHT_MIN, TERRAIN_HEIGHT_MAX, heightMap.get(x, y))
            let pos = ORIGIN_VEC.add(x * TILE_DISTANCE, y * TILE_DISTANCE)
            pos.addTerrainHeight(z - TERRAIN_HEIGHT_INIT)  // Terrain has to have water on it before hand for it to show up
            // Assert that pathing is set to deep water beforehand
            if z >= HEIGHT_LAND_MIN
                let tile = pos.getTile()
                tile.setPathing(PATHING_TYPE_FLOATABILITY, false)
                tile.setPathing(PATHING_TYPE_WALKABILITY, true)
                tile.setPathing(PATHING_TYPE_BUILDABILITY, true)
            else if z >= HEIGHT_SHALLOW_WATER_MIN
                let tile = pos.getTile()
                tile.setPathing(PATHING_TYPE_WALKABILITY, true)
                tile.setPathing(PATHING_TYPE_BUILDABILITY, false)
            compCost += 1.2
        compCost = checkComputationCost(compCost)

public function generatePlants()
    var compCost = 0.
    // Have 1 or 0 tree per tile:
    let treeMap = generatePerlinNoise(TILES_X, TILES_Y, 5, 0.6, "Cosine")
    newInitSubStatus("Add plants")
    for	x = 0 to TILES_X - 1
        updateInitStatus(x + 1, TILES_X)
        for	y = 0 to TILES_Y - 1
            if treeMap.get(x, y) >= GetRandomReal(TREE_COVERAGE_PERCENTAGE_MIN, TREE_COVERAGE_PERCENTAGE_MAX)  // Noise value is the probability, thus compare to random value
                let pos = ORIGIN_VEC + vec2(x + GetRandomReal(-0.5, 0.5), y + GetRandomReal(-0.5, 0.5)) * TILE_DISTANCE
                // createUnit(NATURE_PLAYER, UnitIdsCustom.Trees.beech.getUnitTypeId(), pos, getRandomAngle())
                entity(null, createDestructable(DestructableIds.summerTreeWall, pos, getRandomAngle(), GetRandomReal(0.8, 1.2), GetRandomInt(0, 9))).tryAddResouce()  // TODO: create/use custom destructable with defined values
            compCost += 0.1
        compCost = checkComputationCost(compCost)