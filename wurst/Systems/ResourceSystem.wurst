/*-------------------------------------------------------------
// Version number:
1.01

// Description:
Gives predefined unit types resources wares that can be extracted by workers via the harvest ability.

// Changelog:
- 1.01:
Initial version.
-------------------------------------------------------------*/
package ResourceSystem
import RegisterEvents
import LinkedList
import HashMap
import ConstantDataSystem
import MultiboardPrioritySystem
import StorageSystem
import UtilityFunctions
import OnUnitEnterLeave
import ClosureTimers
import Ability_Harvest
import Orders


// --------------------
// Data code
// --------------------

let countPlayers = 12  // Highest player slot in use
let infoMsgTime = 2.
let autoCastDelay = 0.25

function getDefaultInitWares(int unitId) returns LinkedList<ware>
	var wares = new LinkedList<ware>()
	switch unitId
		case UnitIdsCustom.beech
			wares.add(ware(WareType.Wood, GetRandomInt(6, 8)))
		case UnitIdsCustom.birch
			wares.add(ware(WareType.Wood, GetRandomInt(4, 6)))
		case UnitIdsCustom.greyOak
			wares.add(ware(WareType.Wood, GetRandomInt(6, 8)))
		case UnitIdsCustom.chestnut
			wares.add(ware(WareType.Wood, GetRandomInt(4, 6)))
	return wares

function isKilledWhenDepleted(int unitId) returns bool
	switch unitId
		case UnitIdsCustom.beech
			return true
		case UnitIdsCustom.birch
			return true
		case UnitIdsCustom.greyOak
			return true
		case UnitIdsCustom.chestnut
			return true
		default
			return false

function getWorkProgressPerHarvest(int workerUnitId, int resourceUnitId) returns real
	switch resourceUnitId
		case UnitIdsCustom.beech
			switch workerUnitId
				case UnitIdsCustom.peasant
					return 0.67
			return 0.5
		case UnitIdsCustom.birch
			return 0.5
		case UnitIdsCustom.greyOak
			return 0.5
		case UnitIdsCustom.chestnut
			return 0.5
		default
			return 0.

function getWaresPerFinishedWork(int unitId) returns LinkedList<ware>
	var wares = new LinkedList<ware>()
	switch unitId
		case UnitIdsCustom.beech
			wares.add(ware(WareType.Wood, 1))
		case UnitIdsCustom.birch
			wares.add(ware(WareType.Wood, 1))
		case UnitIdsCustom.greyOak
			wares.add(ware(WareType.Wood, 1))
		case UnitIdsCustom.chestnut
			wares.add(ware(WareType.Wood, 1))
	return wares
			
	
// --------------------
// Functional code
// --------------------

let resourceMap = new HashMap<unit, Resource>  // TODO: maybe make a general unit to class hash map system with corresponding utility functions

class Resource
	private unit resource
	private bool isKilledWhenDepleted
	private real workProgress
	private LinkedList<ware> storedWares

	construct(unit resource, bool isKilledWhenDepleted, LinkedList<ware> initWares)
		this.resource = resource
		this.isKilledWhenDepleted = isKilledWhenDepleted
		workProgress = 0.
		storedWares = initWares

	ondestroy
		destroy storedWares

	function getWare(int index) returns ware
		if index >= storedWares.size()
			Log.error("ERROR: Index has to be smaller than list size")
		return storedWares.get(index)
		
	function getAmountOfWareTypes() returns int
		return storedWares.size()

	function getWareCount(WareType wt) returns int
		for iWare in storedWares
			if iWare.wareType == wt
				return iWare.count
		return 0
	
	function removeWare(ware w)
		for iWare in storedWares
			if iWare.hasSameType(w)
				if iWare.count <= w.count
					storedWares.remove(iWare)
				else
					storedWares.replace(iWare, iWare.changedCopy(-w.count))

	function work(real workProgress) returns bool
		this.workProgress += workProgress
		if this.workProgress >= 1.
			this.workProgress -= 1.
			return true
		else
			return false

	function checkForDepletionKill() returns bool
		if isKilledWhenDepleted and storedWares.isEmpty()
			return true
		return false


function addResource(unit target)
	if resourceMap.has(target) == false
		var unitType = getUnitId(target)
		var wares = getDefaultInitWares(unitType)
		if wares.isEmpty()
			destroy wares
		else
			var resource = new Resource(target, isKilledWhenDepleted(unitType), wares)
			resourceMap.put(target, resource)
	
function removeResource(unit target)
	if resourceMap.has(target)
		destroy resourceMap.get(target)
		resourceMap.remove(target)

/** Returns harvest validity: 1=Valid 2=InvalidWorker 3=InvalidTarget 4=NoFreeStorage 5=ResourceIsDepleted */
function getHarvestValidity(unit worker, unit target) returns int
	// Check if source and target are valid:
	var storage = getStorage(worker)
	if storage == null
		return 2
	var resource = getResource(target)
	if resource == null
		return 3
	// Check if wares can be harvested:
	if storage.getFreeCapacity() <= 0
		return 4
	else if resource.getAmountOfWareTypes() <= 0
		return 5
	else
		return 1
		
/** Perform harvest and returns if another harvest with the given target is still valid. */
function harvest(unit worker, unit target) returns bool
	let storage = getStorage(worker)
	let resource = getResource(target)
	let resourceUnitId = getUnitId(target)
	// Work resource:
	if resource.work(getWorkProgressPerHarvest(getUnitId(worker), resourceUnitId))
		// Transfere wares:
		let wares = getWaresPerFinishedWork(resourceUnitId)
		for iWare in wares
			// Check resource count:
			let resourceWareCount = resource.getWareCount(iWare.wareType)
			if resourceWareCount > 0
				// Limit by resource count:
				if resourceWareCount < iWare.count
					iWare.count = resourceWareCount
				// Add ware to storage:
				var excess = storage.addWare(iWare)
				// Remove ware from resource:
				if excess < iWare.count
					iWare.count -= excess
					resource.removeWare(iWare)
		destroy wares
		// Check for resource depletion:
		if resource.checkForDepletionKill()
			target.kill()
			return false
	return getHarvestValidity(worker, target) == 1
		
/** Returns the resource of given unit. */
public function getResource(unit target) returns Resource
	if resourceMap.has(target)
		return resourceMap.get(target)
	else
		return null

/** Sets system relevant infos for given object in target multiboard. */
public function setObjectInfoMultiboard(multiboard m, Resource r) returns bool
	addMultiboardLine(m, "Resource:", headlineIconPath)
	for i = 0 to (r.getAmountOfWareTypes() - 1)
		var ware = r.getWare(i)
		addMultiboardLine(m, ware.count.toString() + " " + ware.toString(true), ware.getIconPath())
	return true
	
init
	// Add resource to every appropriate new unit:
	onEnter() -> 
		addResource(getEnterLeaveUnit())
	// Remove resource from every appropriate removed unit:
	onLeave() -> 
		removeResource(getEnterLeaveUnit())
	// Register harvest spell:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CAST) ->
		if GetSpellAbilityId() == AbilityIdsCustom.harvest
			let worker = GetTriggerUnit()
			let target = GetSpellTargetUnit()
			let validity = getHarvestValidity(worker, target)
			if validity != 1
				// React on invalid command:
				switch validity
					case 2  // InvalidWorker
						printTimedToPlayer("Invalid: No storage for harvest", infoMsgTime, worker.getOwner())
					case 3  // InvalidTarget
						printTimedToPlayer("Invalid: Harvest target is no resource", infoMsgTime, worker.getOwner())
					case 4  // NoFreeStorage
						printTimedToPlayer("Invalid: No free storage for harvest", infoMsgTime, worker.getOwner())
					case 5  // ResourceIsDepleted
						printTimedToPlayer("Invalid: Harvest target is already depleted", infoMsgTime, worker.getOwner())
				worker.abortOrder()
			else
				// Perform harvest after ability casting is finished:
				doAfter(AbilityData_Harvest.cooldown) ->
					if harvest(worker, target)
						// Auto-recast ability:
						worker.issueTargetAbilityOrder(AbilityIdsCustom.harvest, target, true)
	// Register smart order:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER) ->
		let worker = GetTriggerUnit()
		let target = GetOrderTargetUnit()
		if GetIssuedOrderId() == OrderIds.smart and getHarvestValidity(worker, target) == 1
			worker.issueTargetAbilityOrder(AbilityIdsCustom.harvest, target, true)