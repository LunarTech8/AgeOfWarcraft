/*-------------------------------------------------------------
// Version number:
1.0.0

// Description:
Handles storage buildings that act as ware drop off centres.
Workers fetch/deliver wares from/to other workplace buildings as required.

// Changelog:
- 1.0.0:
Initial version.
-------------------------------------------------------------*/
package DepositorySystem
import ConstantData
import UnitMap
import LinkedList
import Stock
import UtilityFunctions
import MultiboardPrioritySystem
import UnitIndexer
import Icons
import RegisterEvents
import StorageSystem
import WorkplaceSystem
import WorkshopSystem
import ErrorHandling


// --------------------
// Data code
// --------------------

let MAX_AUTO_ORDER_RANGE = 1024.
let WORKERS_ICON_PATH = Icons.bTNBash

/** Returns the maximum ware capacity of the given depository type. */
function getDepositoryMaxCapacity(int depositoryUnitId) returns int
	switch depositoryUnitId
		case UnitIdsCustom.AoW.townHall
			return 500
		default
			return 0


// --------------------
// Functional code
// --------------------

let DEPOSITORY_MAP = new IterableUnitHashMap<Depository>(null)

public class Depository extends Workplace
	private Storage storage

	construct(unit depository)
		super(depository)
		storage = new Storage(depository, getDepositoryMaxCapacity(GetUnitTypeId(depository)))

	ondestroy
		destroy storage

	function getStorage() returns Storage
		return storage

	/** Searches for a task for the given worker if he is near the building else orders him to move there. Returns if no task could be found. */
	function orderWorking(unit worker, bool isNearBuilding) returns bool
		// Go to buidling:
		if isNearBuilding == false
			worker.issueTargetAbilityOrder(AbilityIdsCustom.enterBuilding, user, true)
			return false
		// Search for workshop in need of educts:
		var target = this.findNextWorkshopInNeedOfEducts()
		if target != null
			// Give needed educts to worker:
			let educts = target.getWorkshop().getEducts()
			let workshopStock = target.getWorkshop().getStock()
			let workerStorage = worker.getStorage()
			for iWare in educts
				let wareCount = min(iWare.count * MAX_STORABLE_EDUCTS - workshopStock.getWareCount(iWare.wareType), storage.getWareCount(iWare.wareType), workerStorage.getFreeCapacity())
				if wareCount > 0
					// Transfer ware:
					storage.removeWare(ware(iWare.wareType, wareCount))
					workerStorage.addWare(ware(iWare.wareType, wareCount))
			destroy educts
			// Order ware transfer:
			worker.issueTargetAbilityOrder(AbilityIdsCustom.transferWares, target, true)
			return false
		// Search for workplace with products:
		target = this.findNextWorkplaceWithProducts()
		if target != null
			// Order ware transfer:
			worker.issueTargetAbilityOrder(AbilityIdsCustom.transferWares, target, true)
			return false
		// Nothing to do at the moment, enter building:
		return true

	/** Transfers as many wares as possible from source to this depository. */
	override function transferWares(Storage source, bool _takeWares)
		// Look for wares in source storage:
		let wares = source.getWares()
		for iWare in wares
			let wareCount = min(iWare.count, storage.getFreeCapacity())
			if wareCount > 0
				// Transfer ware:
				source.removeWare(ware(iWare.wareType, wareCount))
				storage.addWare(ware(iWare.wareType, wareCount))
		destroy wares


function unit.addDepository() returns bool
	if DEPOSITORY_MAP.has(this) == false and getDepositoryMaxCapacity(this.getUnitId()) > 0
		DEPOSITORY_MAP.put(this, new Depository(this))
		return true
	return false

function unit.removeDepository()
	let depository = DEPOSITORY_MAP.tryRemove(this)
	if depository != null
		destroy depository

Storage findNextWorkshopInNeedOfEducts_SourceStorage
int findNextWorkshopInNeedOfEducts_NeededEducts
let findNextWorkshopInNeedOfEducts_ValidUnits = CreateGroup()
function findNextWorkshopInNeedOfEducts_CheckValidity() returns bool
	let workshop = GetFilterUnit().getWorkshop()
	// Only allow workshops that require any of the available wares and need more educts:
	if workshop != null and findNextWorkshopInNeedOfEducts_SourceStorage.hasWaresAny(workshop.getEducts())
		let neededEducts = MAX_STORABLE_EDUCTS - workshop.getStoredEductsCount()
		if neededEducts >= findNextWorkshopInNeedOfEducts_NeededEducts
			findNextWorkshopInNeedOfEducts_NeededEducts = neededEducts
			return true
	return false
/** Returns next valid workshop unit in need of educts for this depository. */
function Depository.findNextWorkshopInNeedOfEducts() returns unit
	// Check if wares are available:
	findNextWorkshopInNeedOfEducts_SourceStorage = this.getStorage()
	if findNextWorkshopInNeedOfEducts_SourceStorage.isEmpty() == false
		let pos = this.getUnit().getPos()
		// Get valid workshops in range and get highest amount of needed educts:
		findNextWorkshopInNeedOfEducts_NeededEducts = 1
		let filter = Filter(() -> findNextWorkshopInNeedOfEducts_CheckValidity())
		ENUM_GROUP.enumUnitsInRange(pos, MAX_AUTO_ORDER_RANGE, filter)
		filter.destr()
		// Remove workshops with lower amount of needed educts:
		for target from ENUM_GROUP
			if MAX_STORABLE_EDUCTS - target.getWorkshop().getStoredEductsCount() == findNextWorkshopInNeedOfEducts_NeededEducts
				findNextWorkshopInNeedOfEducts_ValidUnits.addUnit(target)
		// Return nearest valid workshop:
		return pos.getNearestUnit(findNextWorkshopInNeedOfEducts_ValidUnits, true)
	return null

/** Returns next valid workshop or gatherplace unit with products for this depository. */
function Depository.findNextWorkplaceWithProducts() returns unit
	// TODO: implement
	return null

/** Returns if given unit is a depository. */
public function unit.isDepository() returns bool
	return DEPOSITORY_MAP.has(this)

/** Returns the depository of given unit. */
public function unit.getDepository() returns Depository
	return DEPOSITORY_MAP.tryGet(this)

/** Creates and returns a depository building with given values. */
public function createDepositoryBuilding(player owner, int unitId, vec2 pos, angle facing) returns unit
	let building = createUnit(owner, unitId, pos, facing)
	if building.addDepository() == false
		error("Could not create " + building.getName() + " as depository building")
	return building

/** Try to set system relevant infos for given object in this multiboard. Returns if it could be set. */
public function multiboard.trySetObjectInfoMultiboard(Depository object) returns bool
	if object == null
		return false
	let storage = object.getStorage()
	this.addMultiboardLine("Depository: " + object.user.getName(), HEADLINE_ICON_PATH)
	this.addMultiboardLine("Workers: " + object.getWorkerCount().toString() + "/" + object.getMaxWorkerSlots().toString(), WORKERS_ICON_PATH)
	this.addMultiboardLine("Capacity: " + storage.getUsedCapacity().toString() + "/" + storage.getMaxCapacity().toString(), SUB_HEADLINE_ICON_PATH)
	for i = 0 to (storage.getAmountOfWareTypes() - 1)
		let ware = storage.getWare(i)
		this.addMultiboardLine(storage.getWareCount(ware.wareType).toString() + " " + ware.toString(true), ware.getIconPath())
	return true

init
	// Add depository to every appropriate new unit:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_UPGRADE_FINISH, () -> GetTriggerUnit().addDepository())
	// Remove depository from every appropriate removed unit:
	onUnitDeindex(() -> getIndexingUnit().removeDepository())