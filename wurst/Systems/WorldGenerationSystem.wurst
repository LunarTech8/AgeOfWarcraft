/*-------------------------------------------------------------
// Version number:
1.0.0

// Description:
Handles world map generation like terrain deformation and unit placement.

// Changelog:
- 1.0.0:
Initial version.
-------------------------------------------------------------*/
package WorldGenerationSystem
import TerrainUtils
import Interpolation
import Array2D
import ConstantData
import UtilityFunctions
import Entity
import ResourceSystem
import LoadStatusSystem
import ComputationControl
import Destructable_Spruce
import NoiseFunctions
import SaveLoadData
import UnitTest


// --------------------
// Data code
// --------------------

// General:
let TILES_X = 104
let TILES_Y = 104
let ORIGIN_VEC = vec2(-6656., -7168.)  // Left, bottom point from which the terrain generation starts towards right, top point
let USER_PLAYER = Player(0)
let WORLD_DATA_LOAD = false
let WORLD_DATA_SAVE = true
let WORLD_DATA_FILE_NAME = "WorldData.pld"  // In folder ..\Documents\Warcraft III\CustomMapData
let WORLD_DATA_PART_LENGTHS = [0, 4, 5]  // Indices where one data value ends and the next one starts

// Terrain:
let TERRAIN_HEIGHT_INIT = 0.
let TERRAIN_HEIGHT_MIN = -64.  // Min HEIGHT_DEEP_WATER_MIN
let TERRAIN_HEIGHT_MAX = HEIGHT_LAND_MIN + 764.  // Max HEIGHT_LAND_MAX

// Plants:
let NATURE_PLAYER = Player(PLAYER_NEUTRAL_PASSIVE)

enum PlantBiomeType
	BARRENS
	MEADOW
	SHRUBLAND
	WOODS
	FOREST

function getPlantBiomeType(real plantNoiseValue) returns PlantBiomeType
	if plantNoiseValue >= 0.8
		return PlantBiomeType.FOREST
	else if plantNoiseValue >= 0.6
		return PlantBiomeType.WOODS
	else if plantNoiseValue >= 0.4
		return PlantBiomeType.SHRUBLAND
	else if plantNoiseValue >= 0.2
		return PlantBiomeType.MEADOW
	else
		return PlantBiomeType.BARRENS


// --------------------
// Functional code
// --------------------

Array2DReal heightMap = new Array2DReal(TILES_X, TILES_Y)
Array2DInt plantMap = new Array2DInt(TILES_X, TILES_Y)

function encodeWorldData() returns ChunkedString
	let maxHeightValueEncoded = (10).pow(WORLD_DATA_PART_LENGTHS[1] - WORLD_DATA_PART_LENGTHS[0])
	let data = new ChunkedString()
	newInitSubStatus("Test9 " + computationCost.toString())  // DEBUG:
	for	x = 0 to TILES_X - 1
		setInitStepStatus(x + 1, TILES_X)  // DEBUG:
		for	y = 0 to TILES_Y - 1
			let heightValueEncoded = (((heightMap.get(x, y) - TERRAIN_HEIGHT_MIN) * 10.).round() + maxHeightValueEncoded).toString().substring(1)  // TODO: improve encoding to use full char range
			let plantValueEncoded = plantMap.get(x, y).toString()  // TODO: improve encoding to use full char range
			data.append(heightValueEncoded + plantValueEncoded)
	return data

function decodeWorldData(ChunkedString data)
	let dataPartLength = WORLD_DATA_PART_LENGTHS[WORLD_DATA_PART_LENGTHS.length - 1]
	newInitSubStatus("Test10 " + computationCost.toString())  // DEBUG:
	for	x = 0 to TILES_X - 1
		setInitStepStatus(x + 1, TILES_X)  // DEBUG:
		for	y = 0 to TILES_Y - 1
			let dataPart = data.getUnsafeSubString((y + TILES_Y * x) * dataPartLength, (y + TILES_Y * x + 1) * dataPartLength)
			var i = 0
			let heightValueDecoded = dataPart.substring(WORLD_DATA_PART_LENGTHS[i], WORLD_DATA_PART_LENGTHS[i] + WORLD_DATA_PART_LENGTHS[i + 1]).toReal() * 0.1 + TERRAIN_HEIGHT_MIN
			i += 1
			let plantValueDecoded = dataPart.substring(WORLD_DATA_PART_LENGTHS[i], WORLD_DATA_PART_LENGTHS[i] + WORLD_DATA_PART_LENGTHS[i + 1]).toInt()
			heightMap.set(x, y, heightValueDecoded)
			plantMap.set(x, y, plantValueDecoded)

function generateWorldData()
	// Create height map:
	newInitStatus("Height data creation")
	var noiseMap = generatePerlinNoise(TILES_X, TILES_Y, 7, 0.6, "Cosine")
	newInitSubStatus("Calculate height data")
	newInitSubStatus("Test5 " + computationCost.toString())  // DEBUG:
	for	x = 0 to TILES_X - 1
		setInitStepStatus(x + 1, TILES_X)
		for	y = 0 to TILES_Y - 1
			heightMap.set(x, y, linear(TERRAIN_HEIGHT_MIN, TERRAIN_HEIGHT_MAX, noiseMap.get(x, y)))
			computationCost += 0.069
		checkForComputationBreak()
	forceComputationBreak()
	destroy noiseMap
	forceComputationBreak()
	// Create plant map:
	newInitStatus("Plant data creation")
	noiseMap = generatePerlinNoise(TILES_X, TILES_Y, 5, 0.6, "Cosine")
	newInitSubStatus("Calculate plant data")
	newInitSubStatus("Test6 " + computationCost.toString())  // DEBUG:
	for	x = 0 to TILES_X - 1
		setInitStepStatus(x + 1, TILES_X)
		for	y = 0 to TILES_Y - 1
			plantMap.set(x, y, getPlantBiomeType(noiseMap.get(x, y)) castTo int)
			computationCost += 0.067
		checkForComputationBreak()
	forceComputationBreak()
	destroy noiseMap

public function createWorldData()
	// Load or generate world data:
	if WORLD_DATA_LOAD  // TEST:
		newInitStatus("World data creation")
		newInitStatus("World data creation")  // FIXME: two calls required to fit with generation task -> mabye split decoding for height and plant
		USER_PLAYER.loadData(WORLD_DATA_FILE_NAME) (status, data) ->
			if status == SUCCESS
				decodeWorldData(data)
			else
				Log.error(status.toString())
	else
		generateWorldData()
	// Save world data if requested:
	if WORLD_DATA_SAVE  // TEST: probably to big world data (271 chunks), but only 64 allowed per file -> mabye better encoding helps or data has to be saved in multiple files
		USER_PLAYER.saveData(WORLD_DATA_FILE_NAME, encodeWorldData())

public function createTerrain()
	newInitStatus("Terrain creation")
	// Adjust the height for each tile:
	newInitSubStatus("Adjust terrain heights")
	newInitSubStatus("Test7 " + computationCost.toString())  // DEBUG:
	for	x = 0 to TILES_X - 1
		setInitStepStatus(x + 1, TILES_X)
		for	y = 0 to TILES_Y - 1
			let z = heightMap.get(x, y)
			let pos = ORIGIN_VEC.add(x * TILE_DISTANCE, y * TILE_DISTANCE)
			pos.addTerrainHeight(z - TERRAIN_HEIGHT_INIT)  // Terrain has to have water on it before hand for it to show up
			let tile = pos.getTile()
			// Assert that pathing is set to deep water beforehand
			if z >= HEIGHT_LAND_MIN
				tile.setPathing(PATHING_TYPE_FLOATABILITY, false)
				tile.setPathing(PATHING_TYPE_WALKABILITY, true)
				tile.setPathing(PATHING_TYPE_BUILDABILITY, true)
			else if z >= HEIGHT_SHALLOW_WATER_MIN
				tile.setPathing(PATHING_TYPE_WALKABILITY, true)
				tile.setPathing(PATHING_TYPE_BUILDABILITY, false)
			computationCost += 0.821
		checkForComputationBreak()

public function createPlants()
	newInitStatus("Plants creation")
	// Have 1 or 0 tree per tile:
	newInitSubStatus("Add trees")
	newInitSubStatus("Test8 " + computationCost.toString())  // DEBUG:
	for	x = 0 to TILES_X - 1
		setInitStepStatus(x + 1, TILES_X)
		for	y = 0 to TILES_Y - 1
			let plantBiome = plantMap.get(x, y) castTo PlantBiomeType
			if plantBiome == FOREST
				let pos = ORIGIN_VEC + vec2(x + GetRandomReal(-0.5, 0.5), y + GetRandomReal(-0.5, 0.5)) * TILE_DISTANCE
				// createUnit(NATURE_PLAYER, UnitIdsCustom.Trees.beech.getUnitTypeId(), pos, getRandomAngle())  // DEBUG:
				// entity(null, createDestructable(DestructableIdsCustom.Trees.spruce, pos, getRandomAngle(), GetRandomReal(DestructableData_Spruce.minScale, DestructableData_Spruce.maxScale), getRandomVariation(DestructableData_Spruce.variations))).tryAddResouce()
				entity(null, createDestructable(DestructableIdsCustom.Trees.spruce, pos, getRandomAngle(), DestructableData_Spruce.maxScale, getRandomVariation(DestructableData_Spruce.variations))).tryAddResouce()
			else if plantBiome == WOODS
				let pos = ORIGIN_VEC + vec2(x + GetRandomReal(-0.5, 0.5), y + GetRandomReal(-0.5, 0.5)) * TILE_DISTANCE
				entity(null, createDestructable(DestructableIdsCustom.Trees.spruce, pos, getRandomAngle(), DestructableData_Spruce.minScale, getRandomVariation(DestructableData_Spruce.variations))).tryAddResouce()
			computationCost += 0.206
		checkForComputationBreak()


// --------------------
// Test code
// --------------------

@Test public function testWorldGenerationSystem_EncodeAndDecode()
	testWorldGenerationSystem_EncodeAndDecode(false)
public function testWorldGenerationSystem_EncodeAndDecode(bool isInGameTest)
	let REAL_COMPARE_DELTA = 0.01
	let MAX_HEIGHT_VALUE_ENCODED = (10).pow(WORLD_DATA_PART_LENGTHS[1] - WORLD_DATA_PART_LENGTHS[0])
	let MAX_PLANT_VALUE_ENCODED = (PlantBiomeType.FOREST castTo int) + 1
	let DATA_PART_LENGTH = WORLD_DATA_PART_LENGTHS[WORLD_DATA_PART_LENGTHS.length - 1]
	let testName = setTestName("testWorldGenerationSystem_EncodeAndDecode", isInGameTest)
	// Set data:
	for	x = 0 to TILES_X - 1
		for	y = 0 to TILES_Y - 1
			heightMap.set(x, y, TERRAIN_HEIGHT_MIN)
			plantMap.set(x, y, 0)
			heightMap.get(x, y).assertEquals(testName, TERRAIN_HEIGHT_MIN, REAL_COMPARE_DELTA)
			plantMap.get(x, y).assertEquals(testName, 0)
	// Encode and check data:
	var encodedData = encodeWorldData()
	encodedData.length().assertEquals(testName, TILES_X * TILES_Y * DATA_PART_LENGTH)
	encodedData.getChunkCount().assertEquals(testName, ((TILES_X * TILES_Y * DATA_PART_LENGTH) / DEFAULT_CHUNK_SIZE).ceil())
	encodedData.getUnsafeSubString(0 * DATA_PART_LENGTH, (0 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0000" + "0")
	encodedData.getUnsafeSubString(1 * DATA_PART_LENGTH, (1 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0000" + "0")
	encodedData.getUnsafeSubString(9 * DATA_PART_LENGTH, (9 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0000" + "0")
	encodedData.getUnsafeSubString(10042 * DATA_PART_LENGTH, (10042 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0000" + "0")
	// Set data:
	for	x = 0 to TILES_X - 1
		for	y = 0 to TILES_Y - 1
			heightMap.set(x, y, ((y + TILES_Y * x) mod MAX_HEIGHT_VALUE_ENCODED) * 0.1 + TERRAIN_HEIGHT_MIN)
			plantMap.set(x, y, (y + TILES_Y * x) mod MAX_PLANT_VALUE_ENCODED)
	heightMap.get(0, 0).assertEquals(testName, 0.0 + TERRAIN_HEIGHT_MIN, REAL_COMPARE_DELTA)
	heightMap.get(0, 1).assertEquals(testName, 0.1 + TERRAIN_HEIGHT_MIN, REAL_COMPARE_DELTA)
	heightMap.get(0, 2).assertEquals(testName, 0.2 + TERRAIN_HEIGHT_MIN, REAL_COMPARE_DELTA)
	heightMap.get(0, 3).assertEquals(testName, 0.3 + TERRAIN_HEIGHT_MIN, REAL_COMPARE_DELTA)
	// Encode and check data:
	encodedData = encodeWorldData()
	encodedData.getUnsafeSubString(0 * DATA_PART_LENGTH, (0 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0000" + "0")
	encodedData.getUnsafeSubString(1 * DATA_PART_LENGTH, (1 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0001" + "1")
	encodedData.getUnsafeSubString(2 * DATA_PART_LENGTH, (2 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0002" + "2")
	encodedData.getUnsafeSubString(3 * DATA_PART_LENGTH, (3 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0003" + "3")
	encodedData.getUnsafeSubString(9 * DATA_PART_LENGTH, (9 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0009" + "4")
	encodedData.getUnsafeSubString(10042 * DATA_PART_LENGTH, (10042 + 1) * DATA_PART_LENGTH).assertEquals(testName, "0042" + "2")
	// Clear data:
	for	x = 0 to TILES_X - 1
		for	y = 0 to TILES_Y - 1
			heightMap.set(x, y, 0.)
			plantMap.set(x, y, 0)
	// Decode and check data:
	decodeWorldData(encodedData)
	for	x = 0 to TILES_X - 1
		for	y = 0 to TILES_Y - 1
			heightMap.get(x, y).assertEquals(testName, ((y + TILES_Y * x) mod MAX_HEIGHT_VALUE_ENCODED) * 0.1 + TERRAIN_HEIGHT_MIN, REAL_COMPARE_DELTA)
			plantMap.get(x, y).assertEquals(testName, (y + TILES_Y * x) mod MAX_PLANT_VALUE_ENCODED)