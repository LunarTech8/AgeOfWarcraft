/*-------------------------------------------------------------
// Version number:
1.01

// Description:
Handles all custom abilities and allows for the addition of custom, unrestricted functionality.

// Changelog:
- 1.01:
Initial version.
-------------------------------------------------------------*/
package AbilitySystem
import RegisterEvents
import ClosureTimers
import ConstantDataSystem
import UtilityFunctions
import Stock
import StorageSystem
import BuildingSystem
import ResourceSystem
import OrderSystem
import Ability_Harvest


// --------------------
// Data code
// --------------------

let INFO_MSG_TIME = 2.

enum Validity
	VALID
	UNREGISTERED
	INVALID_SOURCE
	INVALID_TARGET
	WARES_NOT_AVAILABLE
	NO_FREE_STORAGE
	NO_REQUIRED_WARES
	WORKER_ALREADY_BUILDING
	RESOURCE_IS_DEPLETED

function getInvalidMessageText(int abilityId, Validity val) returns string
	switch abilityId
		case AbilityIdsCustom.transferWares
			switch val
				case INVALID_SOURCE
					return "Unit can't transfer wares"
				case INVALID_TARGET
					return "Can't transfer wares to this kind of target"
				case WARES_NOT_AVAILABLE
					return "No wares to transfer are available"
				case NO_FREE_STORAGE
					return "Target has no free storage for transfer"
				case NO_REQUIRED_WARES
					return "Target has no required wares left"
				default
					return null
		case AbilityIdsCustom.build
			switch val
				case INVALID_SOURCE
					return "Worker can't build at target building site type"
				case INVALID_TARGET
					return "Build target is no building site"
				case WARES_NOT_AVAILABLE
					return "Not all required wares are available for building"
				case WORKER_ALREADY_BUILDING
					return "Worker is already building"
				default
					return null
		case AbilityIdsCustom.harvest
			switch val
				case INVALID_SOURCE
					return "No storage for harvest"
				case INVALID_TARGET
					return "Harvest target is no resource"
				case NO_FREE_STORAGE
					return "No free storage for harvest"
				case RESOURCE_IS_DEPLETED
					return "Harvest target is already depleted"
				default
					return null
	return null


// --------------------
// Functional code
// --------------------

/** Perform harvest and returns if another harvest with the given target is still valid. */
function unit.harvest(unit target) returns bool
	let storage = this.getStorage()
	let resource = target.getResource()
	// Work resource:
	let wares = resource.harvest(this.getUnitId())
	if wares != null
		// Transfere wares:
		for iWare in wares
			// Check resource count:
			let resourceWareCount = resource.getWareCount(iWare.wareType)
			if resourceWareCount > 0
				// Limit by resource count:
				if resourceWareCount < iWare.count
					iWare.count = resourceWareCount
				// Add ware to storage:
				var excess = storage.addWare(iWare)
				// Remove ware from resource:
				if excess < iWare.count
					iWare.count -= excess
					resource.removeWare(iWare)
		destroy wares
		// Check for resource depletion:
		if resource.checkForDepletionKill()
			target.kill()
			return false
	return this.isAbilityValid(AbilityIdsCustom.harvest, target)

/** Transfer wares from the unit to the given target. */
function unit.transferWares(unit target)
	// Check if wares can be transfered:
	var sourceStorage = this.getStorage()
	if sourceStorage != null
		// Check for possible transfer methods based on target:
		var targetStorage = target.getStorage()
		if targetStorage != null
			// Give wares to target storage:
			sourceStorage.transferWares(targetStorage)
		var targetBuildingSite = target.getBuildingSite()
		if targetBuildingSite != null
			// Take wares from source storage:
			targetBuildingSite.transferWares(sourceStorage)
			// Call over idel workers if no required wares are missing:
			if targetBuildingSite.hasWares() == false
				targetBuildingSite.callOverIdleWorkers(this)

/** Run general reaction on invalid ability command. */
function unit.reactOnInvalidAbility(int abilityId, Validity val)
	if val == Validity.VALID or val == Validity.UNREGISTERED
		Log.error("ERROR: Given validity is not invalid (" + (val castTo int).toString() + ")")

	// React on invalid command:
	let owner = this.getOwner()
	if IsUnitSelected(this, owner)
		let messageText = getInvalidMessageText(abilityId, val)
		if messageText == null
			Log.error("ERROR: Unregistered invalidity message text for " + abilityId.toString() + " / " + (val castTo int).toString())
		printTimedToPlayer("Invalid: " + messageText, INFO_MSG_TIME, owner)
	this.abortOrder()

/** Returns the units validity for casting given ability on given target. */
function unit.getAbilityValidity(int abilityId, unit target) returns Validity
	if abilityId == AbilityIdsCustom.transferWares
		// Check if source and target are valid:
		var sourceStorage = this.getStorage()
		if sourceStorage == null
			return Validity.INVALID_SOURCE
		var targetStorage = target.getStorage()
		var targetBuildingSite = target.getBuildingSite()
		if targetStorage == null and targetBuildingSite == null
			return Validity.INVALID_TARGET
		// Check if wares are available:
		if sourceStorage.getUsedCapacity() <= 0
			return Validity.WARES_NOT_AVAILABLE
		// Check if target has free storage:
		if targetStorage != null and targetStorage.getFreeCapacity() <= 0
			return Validity.NO_FREE_STORAGE
		// Check if target requires wares:
		if targetBuildingSite != null and targetBuildingSite.hasWares() == false
			return Validity.NO_REQUIRED_WARES
	else if abilityId == AbilityIdsCustom.build
		// Check if source and target are valid:
		if target.getUnitId().isValidWorkerType(this.getUnitId()) == false
			return Validity.INVALID_SOURCE
		var buildingSite = target.getBuildingSite()
		if buildingSite == null
			return Validity.INVALID_TARGET
		// Check if required wares are available:
		if buildingSite.hasWares()
			return Validity.WARES_NOT_AVAILABLE
		// Check if worker is already building:
		if this.getBuildingSiteOfWorker() != null
			return Validity.WORKER_ALREADY_BUILDING
	else if abilityId == AbilityIdsCustom.harvest
		// Check if source and target are valid:
		var storage = this.getStorage()
		if storage == null
			return Validity.INVALID_SOURCE
		var resource = target.getResource()
		if resource == null
			return Validity.INVALID_TARGET
		// Check if wares can be harvested:
		if storage.getFreeCapacity() <= 0
			return Validity.NO_FREE_STORAGE
		else if resource.hasWares() == false
			return Validity.RESOURCE_IS_DEPLETED
	else
		// Unregistered abilityId:
		return Validity.UNREGISTERED
	// No validity check failed:
	return Validity.VALID

/** Returns if casting given ability by the unit on given target is valid. */
public function unit.isAbilityValid(int abilityId, unit target) returns bool
	return this.getAbilityValidity(abilityId, target) == Validity.VALID

init
	// Register abilities being cast:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CAST) ->
		let source = GetTriggerUnit()
		let target = GetSpellTargetUnit()
		let abilityId = GetSpellAbilityId()
		let val = source.getAbilityValidity(abilityId, target)
		if val == Validity.VALID
			switch abilityId
				case AbilityIdsCustom.transferWares
					// Transfer wares from source to target:
					source.transferWares(target)
				case AbilityIdsCustom.build
					// Add worker to building site:
					target.getBuildingSite().addWorker(source)
				case AbilityIdsCustom.harvest
					// Perform harvest after ability casting is finished:
					doAfter(AbilityData_Harvest.cooldown) ->
						if source.harvest(target) and source.isOrder(AbilityData_Harvest.baseOrderId, target)
							// Auto-recast ability:
							source.issueTargetAbilityOrder(AbilityIdsCustom.harvest, target, true)
		else if val != Validity.UNREGISTERED
			source.reactOnInvalidAbility(abilityId, val)