/*-------------------------------------------------------------
// Version number:
1.0.0

// Description:
TODO

// Changelog:
- 1.0.0:
Initial version.
-------------------------------------------------------------*/
package WorkshopSystem
import ConstantDataSystem
import UnitMap
import LinkedList
import Stock
import UtilityFunctions
import MultiboardPrioritySystem
import UnitIndexer
import ClosureTimers
import OnUnitEnterLeave
import Icons
import RegisterEvents


// --------------------
// Data code
// --------------------

let PRODUCTION_ADJUSTMENT_RATE = 0.1
let PRODUCTION_PROGRESS_ICON_PATH = Icons.bTNEngineeringUpgrade
let PRODUCTION_TIME_LEFT_ICON_PATH = Icons.bTNStatUp
let WORKERS_ICON_PATH = Icons.bTNBash
let CAPACITY_ICON_PATH = Icons.bTNSnazzyScroll

function getWorkshopMaxCapacity(int buildingId) returns int
	switch buildingId
		case UnitIdsCustom.Melee.lumberMill
			return 50
		case UnitIdsCustom.Melee.blacksmith
			return 50
		default
			return 0

/** Returns the production progress that the given worker type does per second in the given building type. */
function getUnitWorkPower(int workerUnitId, int buildingUnitId) returns real
	switch workerUnitId
		case UnitIdsCustom.Melee.peasant
			switch buildingUnitId
				case UnitIdsCustom.Melee.lumberMill
					return 1.
				case UnitIdsCustom.Melee.blacksmith
					return 1.
	return 0.

/** Returns the required production progress in seconds of the given building type. */
function getRequiredWorkPower(int buildingUnitId, int productionVariant) returns real
	switch buildingUnitId
		case UnitIdsCustom.Melee.lumberMill
			switch productionVariant
				case 1
					return 15.
				case 2
					return 10.
		case UnitIdsCustom.Melee.blacksmith
			switch productionVariant
				case 1
					return 20.
	return 0.

function getMaxWorkers(int buildingUnitId) returns int
	switch buildingUnitId
		case UnitIdsCustom.Melee.lumberMill
			return 3
		case UnitIdsCustom.Melee.blacksmith
			return 3
	return 0

function getEducts(int workshopUnitId, int productionVariant) returns LinkedList<ware>
	var wares = new LinkedList<ware>()
	switch workshopUnitId
		case UnitIdsCustom.Melee.lumberMill
			switch productionVariant
				case 1
					wares.add(ware(WareType.WOOD, 3))
				case 2
					wares.add(ware(WareType.WOOD, 1))
		case UnitIdsCustom.Melee.blacksmith
			switch productionVariant
				case 1
					wares.add(ware(WareType.IRON_ORE, 1))
					wares.add(ware(WareType.COAL, 1))
	return wares

function getProducts(int workshopUnitId, int productionVariant) returns LinkedList<ware>
	var wares = new LinkedList<ware>()
	switch workshopUnitId
		case UnitIdsCustom.Melee.lumberMill
			switch productionVariant
				case 1
					wares.add(ware(WareType.WOODEN_BOARDS, 2))
				case 2
					wares.add(ware(WareType.WOODEN_STICKS, 1))
		case UnitIdsCustom.Melee.blacksmith
			switch productionVariant
				case 1
					wares.add(ware(WareType.METAL, 1))
	return wares


// --------------------
// Functional code
// --------------------

let WORKSHOP_MAP = new IterableUnitHashMap<Workshop>(null)

class Workshop extends Stock
	private int maxCapacity
	private int usedCapacity
	private int productionVariant
	private real workProgressCurrent
	private real workProgressFinished
	private real workPower
	private group workers

	construct(unit workshop, int maxCapacity)
		super(new LinkedList<ware>())
		user = workshop
		this.maxCapacity = maxCapacity
		usedCapacity = 0
		productionVariant = 1
		workProgressCurrent = 0.
		workProgressFinished = getRequiredWorkPower(workshop.getUnitId(), productionVariant)
		workPower = 0.
		workers = CreateGroup()

	ondestroy
		for worker in workers
			worker.show()
		workers.destr()

	function getMaxCapacity() returns int
		return maxCapacity

	function getUsedCapacity() returns int
		return usedCapacity

	function getFreeCapacity() returns int
		return maxCapacity - usedCapacity

	override function addWare(ware w)
		if w.count > getFreeCapacity()
			Log.error("ERROR: Not enough free capacity to add given ware to storage of " + user.getName())
		usedCapacity += w.count
		super.addWare(w)

	override function addWares(LinkedList<ware> wares)
		for iWare in wares
			addWare(iWare)  // Use capacity based method

	override function removeWare(ware w)
		for iWare in wares
			if iWare.hasSameType(w)
				// Check and adjust ware:
				if iWare.count < w.count
					Log.error("ERROR: Can not remove given ware from storage of " + user.getName() + " because ware count is to low")
				else if iWare.count == w.count
					wares.remove(iWare)
				else
					wares.replace(iWare, iWare.changedCopy(-w.count))
				// Adjust capacity:
				usedCapacity -= w.count
				return
		Log.error("ERROR: Can not remove given ware from storage of " + user.getName() + " because ware type is not available")

	override function removeWares(LinkedList<ware> wares)
		for iWare in wares
			removeWare(iWare)  // Use capacity based method

	private function startProduction() returns bool
		// Check if a new production can be startet:
		let educts = getEducts(user.getUnitId(), productionVariant)
		if hasWares(educts)
			// Start production:
			removeWares(educts)
			destroy educts
			return true
		else
			// Not enough educts:
			destroy educts
			return false

	function getUnitId() returns int
		return user.getUnitId()

	function getProductionVariant() returns int
		return productionVariant

	function getWorkerCount() returns int
		return workers.size()

	function getWorkProgressPercentage() returns real
		return workProgressCurrent / workProgressFinished

	function getWorkProgressLeft() returns real
		return workProgressFinished - workProgressCurrent

	function getWorkPower() returns real
		return workPower

	function addWorker(unit worker)
		if workers.contains(worker) == false and workers.size() < getMaxWorkers(user.getUnitId())
			workers.addUnit(worker)
			workPower += getUnitWorkPower(worker.getUnitId(), user.getUnitId())
			worker.hide()
		else
			Log.error("ERROR: Can't add worker to this workshop")

	function removeWorker(unit worker)
		if workers.contains(worker)
			workers.removeUnit(worker)
			workPower -= getUnitWorkPower(worker.getUnitId(), user.getUnitId())
			worker.show()
		else
			Log.error("ERROR: Can't remove worker from this workshop")

	function adjustProgress() returns bool
		if workPower > 0.
			// Check if a new production has to be startet:
			if workProgressCurrent <= 0. and startProduction() == false
				return false
			// Adjust work progress:
			workProgressCurrent += workPower * PRODUCTION_ADJUSTMENT_RATE
			if workProgressCurrent >= workProgressFinished
				// Finish production:
				let products = getProducts(user.getUnitId(), productionVariant)
				addWares(products)
				destroy products
				// Directly start with next production if possible:
				if startProduction()
					workProgressCurrent -= workProgressFinished
				else
					workProgressCurrent = 0.
				return true
		return false


function unit.addWorkshop()
	let maxCapacity = getWorkshopMaxCapacity(this.getUnitId())
	if WORKSHOP_MAP.has(this) == false and maxCapacity > 0
		WORKSHOP_MAP.put(this, new Workshop(this, maxCapacity))

function unit.removeWorkshop()
	let workshop = WORKSHOP_MAP.tryRemove(this)
	if workshop != null
		destroy workshop

/** Returns the workshop of given unit. */
public function unit.getWorkshop() returns Workshop
	return WORKSHOP_MAP.tryGet(this)

/** Sets system relevant infos for given object in target multiboard. _isWorkshop only exists to avoid ambiguity with StorageSystem. */
public function multiboard.setObjectInfoMultiboard(Workshop ws, bool _isWorkshop) returns bool
	this.addMultiboardLine("Workshop:", HEADLINE_ICON_PATH)
	this.addMultiboardLine("Production progress: " + ws.getWorkProgressPercentage().toInt().toString() + "%", PRODUCTION_PROGRESS_ICON_PATH)
	let workPower = ws.getWorkPower()
	if workPower > 0.
		this.addMultiboardLine("Production time left: " + (ws.getWorkProgressLeft() / workPower).toInt().toString() + "s", PRODUCTION_TIME_LEFT_ICON_PATH)
		this.addMultiboardLine("Workers: " + ws.getWorkerCount().toString(), WORKERS_ICON_PATH)
	let unitId = ws.getUnitId()
	let productionVariant = ws.getProductionVariant()
	this.addMultiboardLine("Educts:", SUB_HEADLINE_ICON_PATH)
	let educts = getEducts(unitId, productionVariant)
	for ware in educts
		this.addMultiboardLine(ware.count.toString() + " " + ware.toString(true), ware.getIconPath())
	destroy educts
	this.addMultiboardLine("Products:", SUB_HEADLINE_ICON_PATH)
	let products = getProducts(unitId, productionVariant)
	for ware in products
		this.addMultiboardLine(ware.count.toString() + " " + ware.toString(true), ware.getIconPath())
	destroy products
	this.addMultiboardLine("Storage:", SUB_HEADLINE_ICON_PATH)
	this.addMultiboardLine("Capacity: " + ws.getUsedCapacity().toString() + "/" + ws.getMaxCapacity().toString(), CAPACITY_ICON_PATH)
	for i = 0 to (ws.getAmountOfWareTypes() - 1)
		var ware = ws.getWare(i)
		this.addMultiboardLine(ware.count.toString() + " " + ware.toString(true), ware.getIconPath())
	return true

init
	// Add workshop to every appropriate new unit:
	onEnter() ->
		getEnterLeaveUnit().addWorkshop()
	// Remove workshop from every appropriate removed unit:
	onUnitDeindex() ->
		getIndexingUnit().removeWorkshop()
	// Register construction finishes:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_UPGRADE_FINISH) ->
		GetTriggerUnit().addWorkshop()
	// Adjust progress of all workshops:
	doPeriodically(PRODUCTION_ADJUSTMENT_RATE) cb ->
		for building in WORKSHOP_MAP
			if building != null
				WORKSHOP_MAP.get(building).adjustProgress()