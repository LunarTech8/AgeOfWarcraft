/*-------------------------------------------------------------
// Version number:
1.0.0

// Description:
Extension of the Stock class that adds a capacity to every ware of size one and a unit type dependant max capacity.

// Changelog:
- 1.0.0:
Initial version.
-------------------------------------------------------------*/
package StorageSystem
import OnUnitEnterLeave
import Icons
import ConstantDataSystem
import MultiboardPrioritySystem
import Stock
import UnitMap
import ArrayList


// --------------------
// Data code
// --------------------

public let STORAGE_MIN_WARE_TYPE_COUNT = 8
let CAPACITY_ICON_PATH = Icons.bTNSnazzyScroll

function getMaxCapacity(int unitId) returns int
	switch unitId
		case UnitIdsCustom.peasant
			// return 10
			return 100  // DEBUG
		default
			return 0


// --------------------
// Functional code
// --------------------

let STORAGE_MAP = new UnitDynamicIndexMap<Storage>(null, INIT_UNIT_INDEX_SIZE)

public class Storage extends Stock
	private int maxCapacity
	private int usedCapacity

	construct(unit storage, int maxCapacity)
		super(new ArrayList<ware>(STORAGE_MIN_WARE_TYPE_COUNT))
		user = storage
		this.maxCapacity = maxCapacity
		usedCapacity = 0

	function getMaxCapacity() returns int
		return maxCapacity

	function getUsedCapacity() returns int
		return usedCapacity

	function getFreeCapacity() returns int
		return maxCapacity - usedCapacity

	override function addWare(ware w)
		if w.count > getFreeCapacity()
			Log.error("ERROR: Not enough free capacity to add given ware to storage of " + user.getName())
		usedCapacity =- w.count
		super.addWare(w)

	override function addWares(ArrayList<ware> wares)
		for iWare in wares
			addWare(iWare)

	override function removeWare(ware w)
		for iWare in wares
			if iWare.hasSameType(w)
				// Check and adjust ware:
				if iWare.count < w.count
					Log.error("ERROR: Can not remove given ware from storage of " + user.getName() + " because ware count is to low")
				else if iWare.count == w.count
					wares.remove(iWare)
				else
					wares.replace(iWare, iWare.changedCopy(-w.count))
				// Adjust capacity:
				usedCapacity -= w.count
				return
		Log.error("ERROR: Can not remove given ware from storage of " + user.getName() + " because ware type is not available")

	/** Returns the amount of wares that couldn't be transfered. */
	function transferWares(Storage target) returns int
		// Transfer last ware of source until it is empty or target is full:
		var targetFreeCapacity = target.getFreeCapacity()
		while hasWares()
			if targetFreeCapacity <= 0
				return usedCapacity
			var ware = getLastWare()
			if targetFreeCapacity < ware.count
				ware.count = targetFreeCapacity
			targetFreeCapacity -= ware.count
			target.addWare(ware)
			removeWare(ware)
		return 0


function unit.addStorage()
	if STORAGE_MAP.has(this) == false
		var maxCapacity = getMaxCapacity(GetUnitTypeId(this))
		if maxCapacity > 0
			var storage = new Storage(this, maxCapacity)
			STORAGE_MAP.put(this, storage)

function unit.removeStorage()
	let storage = STORAGE_MAP.tryRemove(this)
	if storage != null
		destroy storage

/** Returns the storage of given unit. */
public function unit.getStorage() returns Storage
	return STORAGE_MAP.tryGet(this)

/** Sets system relevant infos for given object in target multiboard. */
public function multiboard.setObjectInfoMultiboard(Storage s) returns bool
	this.addMultiboardLine("Storage:", HEADLINE_ICON_PATH)
	this.addMultiboardLine("Capacity: " + s.getUsedCapacity().toString() + "/" + s.getMaxCapacity().toString(), CAPACITY_ICON_PATH)
	for i = 0 to (s.getAmountOfWareTypes() - 1)
		var ware = s.getWare(i)
		this.addMultiboardLine(ware.count.toString() + " " + ware.toString(true), ware.getIconPath())
	return true

init
	// Add storage to every appropriate new unit:
	onEnter() ->
		getEnterLeaveUnit().addStorage()
	// Remove storage from every appropriate removed unit:
	onLeave() ->
		getEnterLeaveUnit().removeStorage()