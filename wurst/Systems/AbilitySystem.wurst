/*-------------------------------------------------------------
// Version number:
1.01

// Description:
Handles all custom abilities and allows for the addition of custom, unrestricted functionality.

// Changelog:
- 1.01:
Initial version.
-------------------------------------------------------------*/
package AbilitySystem
import RegisterEvents
import ClosureTimers
import LastOrder
import ConstantDataSystem
import UtilityFunctions
import Stock
import StorageSystem
import BuildingSystem
import ResourceSystem
import Ability_Harvest


// --------------------
// Data code
// --------------------

let INFO_MSG_TIME = 2.

enum Validity
	Valid
	Unregistered
	InvalidSource
	InvalidTarget
	WaresNotAvailable
	NoFreeStorage
	NoRequiredWares
	WorkerAlreadyBuilding
	ResourceIsDepleted

function getInvalidMessageText(int abilityId, Validity val) returns string
	switch abilityId
		case AbilityIdsCustom.transferWares
			switch val
				case InvalidSource
					return "Unit can't transfer wares"
				case InvalidTarget
					return "Can't transfer wares to this kind of target"
				case WaresNotAvailable
					return "No wares to transfer are available"
				case NoFreeStorage
					return "Target has no free storage for transfer"
				case NoRequiredWares
					return "Target has no required wares left"
				default
					return null
		case AbilityIdsCustom.build
			switch val
				case InvalidSource
					return "Worker can't build at target building site type"
				case InvalidTarget
					return "Build target is no building site"
				case WaresNotAvailable
					return "Not all required wares are available for building"
				case WorkerAlreadyBuilding
					return "Worker is already building"
				default
					return null
		case AbilityIdsCustom.harvest
			switch val
				case InvalidSource
					return "No storage for harvest"
				case InvalidTarget
					return "Harvest target is no resource"
				case NoFreeStorage
					return "No free storage for harvest"
				case ResourceIsDepleted
					return "Harvest target is already depleted"
				default
					return null
	return null


// --------------------
// Functional code
// --------------------

/** Perform harvest and returns if another harvest with the given target is still valid. */
function unit.harvest(unit target) returns bool
	let storage = this.getStorage()
	let resource = target.getResource()
	// Work resource:
	let wares = resource.harvest(this.getUnitId())
	if wares != null
		// Transfere wares:
		for iWare in wares
			// Check resource count:
			let resourceWareCount = resource.getWareCount(iWare.wareType)
			if resourceWareCount > 0
				// Limit by resource count:
				if resourceWareCount < iWare.count
					iWare.count = resourceWareCount
				// Add ware to storage:
				var excess = storage.addWare(iWare)
				// Remove ware from resource:
				if excess < iWare.count
					iWare.count -= excess
					resource.removeWare(iWare)
		destroy wares
		// Check for resource depletion:
		if resource.checkForDepletionKill()
			target.kill()
			return false
	return this.isAbilityValid(AbilityIdsCustom.harvest, target)

/** Transfer wares from the unit to the given target. */
function unit.transferWares(unit target)
	// Check if wares can be transfered:
	var sourceStorage = this.getStorage()
	if sourceStorage != null
		// Check for possible transfer methods based on target:
		var targetStorage = target.getStorage()
		if targetStorage != null
			// Give wares to target storage:
			sourceStorage.transferWares(targetStorage)
		var targetBuildingSite = target.getBuildingSite()
		if targetBuildingSite != null
			// Take wares from source storage:
			targetBuildingSite.transferWares(sourceStorage)
			// Call over idel workers if no required wares are missing:
			if targetBuildingSite.hasWares() == false
				targetBuildingSite.callOverIdleWorkers(this)

/** Run general reaction on invalid ability command. */
function unit.reactOnInvalidAbility(int abilityId, Validity val)
	if val == Validity.Valid or val == Validity.Unregistered
		Log.error("ERROR: Given validity is not invalid (" + (val castTo int).toString() + ")")

	// React on invalid command:
	let owner = this.getOwner()
	if IsUnitSelected(this, owner)
		let messageText = getInvalidMessageText(abilityId, val)
		if messageText == null
			Log.error("ERROR: Unregistered invalidity message text for " + abilityId.toString() + " / " + (val castTo int).toString())
		printTimedToPlayer("Invalid: " + messageText, INFO_MSG_TIME, owner)
	this.abortOrder()

/** Returns the units validity for casting given ability on given target. */
function unit.getAbilityValidity(int abilityId, unit target) returns Validity
	if abilityId == AbilityIdsCustom.transferWares
		// Check if source and target are valid:
		var sourceStorage = this.getStorage()
		if sourceStorage == null
			return Validity.InvalidSource
		var targetStorage = target.getStorage()
		var targetBuildingSite = target.getBuildingSite()
		if targetStorage == null and targetBuildingSite == null
			return Validity.InvalidTarget
		// Check if wares are available:
		if sourceStorage.getUsedCapacity() <= 0
			return Validity.WaresNotAvailable
		// Check if target has free storage:
		if targetStorage != null and targetStorage.getFreeCapacity() <= 0
			return Validity.NoFreeStorage
		// Check if target requires wares:
		if targetBuildingSite != null and targetBuildingSite.hasWares() == false
			return Validity.NoRequiredWares
	else if abilityId == AbilityIdsCustom.build
		// Check if source and target are valid:
		if target.getUnitId().isValidWorkerType(this.getUnitId()) == false
			return Validity.InvalidSource
		var buildingSite = target.getBuildingSite()
		if buildingSite == null
			return Validity.InvalidTarget
		// Check if required wares are available:
		if buildingSite.hasWares()
			return Validity.WaresNotAvailable
		// Check if worker is already building:
		if this.getBuildingSiteOfWorker() != null
			return Validity.WorkerAlreadyBuilding
	else if abilityId == AbilityIdsCustom.harvest
		// Check if source and target are valid:
		var storage = this.getStorage()
		if storage == null
			return Validity.InvalidSource
		var resource = target.getResource()
		if resource == null
			return Validity.InvalidTarget
		// Check if wares can be harvested:
		if storage.getFreeCapacity() <= 0
			return Validity.NoFreeStorage
		else if resource.hasWares() == false
			return Validity.ResourceIsDepleted
	else
		// Unregistered abilityId:
		return Validity.Unregistered
	// No validity check failed:
	return Validity.Valid

/** Returns if casting given ability by the unit on given target is valid. */
public function unit.isAbilityValid(int abilityId, unit target) returns bool
	return this.getAbilityValidity(abilityId, target) == Validity.Valid

init
	// Register abilities being cast:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CAST) ->
		let source = GetTriggerUnit()
		let target = GetSpellTargetUnit()
		let abilityId = GetSpellAbilityId()
		let val = source.getAbilityValidity(abilityId, target)
		if val == Validity.Valid
			switch abilityId
				case AbilityIdsCustom.transferWares
					// Transfer wares from source to target:
					source.transferWares(target)
				case AbilityIdsCustom.build
					// Add worker to building site:
					target.getBuildingSite().addWorker(source)
				case AbilityIdsCustom.harvest
					// Perform harvest after ability casting is finished:
					doAfter(AbilityData_Harvest.cooldown) ->
						if source.harvest(target)
							// Auto-recast ability:
							source.issueTargetAbilityOrder(AbilityIdsCustom.harvest, target, true)
		else if val != Validity.Unregistered
			source.reactOnInvalidAbility(abilityId, val)
	// Register issued orders:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER) ->
		let orderId = GetIssuedOrderId()
		let source = GetTriggerUnit()
		// Remove ordered unit from current aim lists:
		let prevOrder = source.getLastOrder().prev
		if prevOrder.finished == false and prevOrder.orderType == OrderType.TARGET
			widget w = prevOrder.target
			// CONTINUE: can't cast widget to unit!!!
			// TODO: maybe replace LastOrder with an own package
			let resource = targetU.getResource()
			if resource != null
				// TODO: remove from last list
		// Add ordered unit to aim list of target:
		if orderId == AbilityIdsCustom.harvest
			let target = GetOrderTargetUnit()
			if source.isAbilityValid(orderId, target)
				target.getResource().addAsTarget(source)