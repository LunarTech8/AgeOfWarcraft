/*-------------------------------------------------------------
// Version number:
1.0.0

// Description:
TODO

// Changelog:
- 1.0.0:
Initial version.
-------------------------------------------------------------*/
package WorkshopSystem
import ConstantDataSystem
import UnitMap
import LinkedList
import Stock
import UtilityFunctions
import MultiboardPrioritySystem
import UnitIndexer
import ClosureTimers
import OnUnitEnterLeave
import Icons
import RegisterEvents
import StorageSystem


// --------------------
// Data code
// --------------------

let MAX_STORABLE_EDUCTS = 5
let MAX_STORABLE_PRODUCTS = 3
let PRODUCTION_ADJUSTMENT_RATE = 0.1
let PRODUCTION_PROGRESS_ICON_PATH = Icons.bTNEngineeringUpgrade
let PRODUCTION_TIME_LEFT_ICON_PATH = Icons.bTNStatUp
let WORKERS_ICON_PATH = Icons.bTNBash

/** Returns the production progress that the given worker type does per second in the given building type. */
function getUnitWorkPower(int workerUnitId, int buildingUnitId) returns real
	switch workerUnitId
		case UnitIdsCustom.Melee.peasant
			switch buildingUnitId
				case UnitIdsCustom.Melee.lumberMill
					return 1.
				case UnitIdsCustom.Melee.blacksmith
					return 1.
	return 0.

/** Returns the required production progress in seconds of the given building type. */
function getRequiredWorkPower(int buildingUnitId, int productionVariant) returns real
	switch buildingUnitId
		case UnitIdsCustom.Melee.lumberMill
			switch productionVariant
				case 1
					return 15.
				case 2
					return 10.
		case UnitIdsCustom.Melee.blacksmith
			switch productionVariant
				case 1
					return 20.
	return 0.

function getWorkshopEducts(int workshopUnitId, int productionVariant) returns LinkedList<ware>
	var wares = new LinkedList<ware>()
	switch workshopUnitId
		case UnitIdsCustom.Melee.lumberMill
			switch productionVariant
				case 1
					wares.add(ware(WareType.WOOD, 3))
				case 2
					wares.add(ware(WareType.WOOD, 1))
		case UnitIdsCustom.Melee.blacksmith
			switch productionVariant
				case 1
					wares.add(ware(WareType.IRON_ORE, 1))
					wares.add(ware(WareType.COAL, 1))
	return wares

function getWorkshopProducts(int workshopUnitId, int productionVariant) returns LinkedList<ware>
	var wares = new LinkedList<ware>()
	switch workshopUnitId
		case UnitIdsCustom.Melee.lumberMill
			switch productionVariant
				case 1
					wares.add(ware(WareType.WOODEN_BOARDS, 2))
				case 2
					wares.add(ware(WareType.WOODEN_STICKS, 1))
		case UnitIdsCustom.Melee.blacksmith
			switch productionVariant
				case 1
					wares.add(ware(WareType.METAL, 1))
	return wares

/** Returns the maximum allowed amount of workers of the given building type. */
public function getMaxWorkers(int buildingUnitId) returns int
	switch buildingUnitId
		case UnitIdsCustom.Melee.lumberMill
			return 3
		case UnitIdsCustom.Melee.blacksmith
			return 3
	return 0


// --------------------
// Functional code
// --------------------

let WORKSHOP_MAP = new IterableUnitHashMap<Workshop>(null)

class Workshop extends Stock
	private int productionVariant
	private real workProgressCurrent
	private real workProgressFinished
	private real workPower
	private group workers

	construct(unit workshop)
		super(new LinkedList<ware>())
		user = workshop
		productionVariant = 1
		workProgressCurrent = 0.
		workProgressFinished = getRequiredWorkPower(workshop.getUnitId(), productionVariant)
		workPower = 0.
		workers = CreateGroup()

	ondestroy
		for worker in workers
			worker.show()
		workers.destr()

	private function startProduction() returns bool
		// Check if there are enough educts:
		let educts = getEducts()
		if hasWares(educts)
			// Check if there is enough free space for the products:
			let products = getProducts()
			for iWare in products
				if getWareCount(iWare.wareType) > iWare.count * (MAX_STORABLE_PRODUCTS - 1)
					// Too many products:
					destroy products
					return false
			destroy products
			// Start production:
			removeWares(educts)
			destroy educts
			return true
		else
			// Not enough educts:
			destroy educts
			return false

	function isValidWorkerType(int unitId) returns bool
		return getUnitWorkPower(unitId, user.getUnitId()) > 0.

	function getStoredEducts() returns int
		var amount = MAX_WARE_COUNT
		let educts = getEducts()
		for iWare in educts
			amount = min(amount, getWareCount(iWare.wareType) div iWare.count)
		destroy educts
		return amount

	function getStoredProducts() returns int
		var amount = MAX_WARE_COUNT
		let products = getProducts()
		for iWare in products
			amount = min(amount, getWareCount(iWare.wareType) div iWare.count)
		destroy products
		return amount

	function getProducts() returns LinkedList<ware>
		return getWorkshopProducts(user.getUnitId(), productionVariant)

	function getEducts() returns LinkedList<ware>
		return getWorkshopEducts(user.getUnitId(), productionVariant)

	function getWorkerCount() returns int
		return workers.size()

	function getWorkProgressPercentage() returns real
		return workProgressCurrent / workProgressFinished

	function getWorkProgressLeft() returns real
		return workProgressFinished - workProgressCurrent

	function getWorkPower() returns real
		return workPower

	function addWorker(unit worker)
		if workers.contains(worker) == false and workers.size() < getMaxWorkers(user.getUnitId())
			workers.addUnit(worker)
			workPower += getUnitWorkPower(worker.getUnitId(), user.getUnitId())
			worker.hide()
		else
			Log.error("ERROR: Can't add worker to this workshop")

	function removeWorker(unit worker)
		if workers.contains(worker)
			workers.removeUnit(worker)
			workPower -= getUnitWorkPower(worker.getUnitId(), user.getUnitId())
			worker.show()
		else
			Log.error("ERROR: Can't remove worker from this workshop")

	function adjustProgress() returns bool
		if workPower > 0.
			// Check if a new production has to be startet:
			if workProgressCurrent <= 0. and startProduction() == false
				return false
			// Adjust work progress:
			workProgressCurrent += workPower * PRODUCTION_ADJUSTMENT_RATE
			if workProgressCurrent >= workProgressFinished
				// Finish production:
				let products = getProducts()
				addWares(products)
				destroy products
				// Directly start with next production if possible:
				if startProduction()
					workProgressCurrent -= workProgressFinished
				else
					workProgressCurrent = 0.
				return true
		return false

	function transferWares(Storage source)
		// Look for educts in source:
		let educts = getEducts()
		for iWare in educts
			var wareCount = min(iWare.count * MAX_STORABLE_EDUCTS - getWareCount(iWare.wareType), source.getWareCount(iWare.wareType))
			if wareCount > 0
				// Transfer ware:
				source.removeWare(ware(iWare.wareType, wareCount))
				addWare(ware(iWare.wareType, wareCount))
		destroy educts
		// Look for products in workshop:
		let products = getProducts()
		for iWare in products
			var wareCount = min(getWareCount(iWare.wareType), source.getFreeCapacity())
			if wareCount > 0
				// Transfer ware:
				removeWare(ware(iWare.wareType, wareCount))
				source.addWare(ware(iWare.wareType, wareCount))
		destroy products


function unit.addWorkshop()
	if WORKSHOP_MAP.has(this) == false and getRequiredWorkPower(this.getUnitId(), 1) > 0.
		WORKSHOP_MAP.put(this, new Workshop(this))

function unit.removeWorkshop()
	let workshop = WORKSHOP_MAP.tryRemove(this)
	if workshop != null
		destroy workshop

/** Returns the workshop of given unit. */
public function unit.getWorkshop() returns Workshop
	return WORKSHOP_MAP.tryGet(this)

/** Sets system relevant infos for given object in target multiboard. */
public function multiboard.setObjectInfoMultiboard(Workshop ws) returns bool
	this.addMultiboardLine("Workshop:", HEADLINE_ICON_PATH)
	this.addMultiboardLine("Production progress: " + ws.getWorkProgressPercentage().toInt().toString() + "%", PRODUCTION_PROGRESS_ICON_PATH)
	let workPower = ws.getWorkPower()
	if workPower > 0.
		this.addMultiboardLine("Production time left: " + (ws.getWorkProgressLeft() / workPower).toInt().toString() + "s", PRODUCTION_TIME_LEFT_ICON_PATH)
		this.addMultiboardLine("Workers: " + ws.getWorkerCount().toString(), WORKERS_ICON_PATH)
	this.addMultiboardLine("Educts (" + ws.getStoredEducts().toString() + "/" + MAX_STORABLE_EDUCTS.toString() + "):", SUB_HEADLINE_ICON_PATH)
	let educts = ws.getEducts()
	for ware in educts
		this.addMultiboardLine(ware.count.toString() + " " + ware.toString(true), ware.getIconPath())
	destroy educts
	this.addMultiboardLine("Products (" + ws.getStoredProducts().toString() + "/" + MAX_STORABLE_PRODUCTS.toString() + ")", SUB_HEADLINE_ICON_PATH)
	let products = ws.getProducts()
	for ware in products
		this.addMultiboardLine(ware.count.toString() + " " + ware.toString(true), ware.getIconPath())
	destroy products
	return true

init
	// Add workshop to every appropriate new unit:
	onEnter() ->
		getEnterLeaveUnit().addWorkshop()
	// Remove workshop from every appropriate removed unit:
	onUnitDeindex() ->
		getIndexingUnit().removeWorkshop()
	// Register construction finishes:
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_UPGRADE_FINISH) ->
		GetTriggerUnit().addWorkshop()
	// Adjust progress of all workshops:
	doPeriodically(PRODUCTION_ADJUSTMENT_RATE) cb ->
		for building in WORKSHOP_MAP
			if building != null
				WORKSHOP_MAP.get(building).adjustProgress()