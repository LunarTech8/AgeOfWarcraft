/*-------------------------------------------------------------
// Version number:
1.01

// Description:
Provides generic lists based on dynamic arrays.

// Changelog:
- 1.01:
Initial version.
-------------------------------------------------------------*/
package ArrayList


// --------------------
// Functional code
// --------------------

interface IArrayList<T>
	function getSize() returns int
	function getUsedSlots() returns int
	function getElem(int index) returns T
	function setElem(int index, T elem)
	function add(T elem)
	function add(int index, T elem)
	function remove(int index)
	function getIndex(T elem) returns int

class ArrayListBase<T>
	protected var usedSlots = 0

	protected function checkSlot(int index, int size)
		if index > size
			Log.error("ERROR: Given index (" + index.toString() + ") is bigger than size of ArrayList (" + size.toString() + ")")
		else if index > usedSlots
			Log.error("ERROR: Size of ArrayList has to be bigger than 0")

/* Generic ArrayList data class with fixed specific array size */
class ArrayListSize2<T> extends ArrayListBase implements IArrayList<T>
	private let size = 2
	private T array[size] data

	override function getSize() returns int
		return size

	override function getUsedSlots() returns int
		return usedSlots

	override function getElem(int index) returns T
		checkSlot(index, size)
		return data[index]

	override function setElem(int index, T elem)
		checkSlot(index, size)
		data[index] = elem

	override function add(T elem)
		usedSlots++
		data[usedSlots] = elem

	override function add(int index, T elem)
		usedSlots++
		for i = usedSlots - 1 downto index + 1
			data[i] = data[i - 1]
		data[index] = elem

	override function remove(int index)
		for i = index to usedSlots - 2
			data[i] = data[i + 1]
		usedSlots--

	override function getIndex(T elem) returns int
		for i = 0 to usedSlots - 1
			if data[i] == elem
				return i
		return 0

/* Generic ArrayList data class with fixed specific array size */
class ArrayListSize4<T> extends ArrayListBase implements IArrayList<T>
	private let size = 4
	private T array[size] data

	override function getSize() returns int
		return size

	override function getUsedSlots() returns int
		return usedSlots

	override function getElem(int index) returns T
		checkSlot(index, size)
		return data[index]

	override function setElem(int index, T elem)
		checkSlot(index, size)
		data[index] = elem

	override function add(T elem)
		usedSlots++
		data[usedSlots] = elem

	override function add(int index, T elem)
		usedSlots++
		for i = usedSlots - 1 downto index + 1
			data[i] = data[i - 1]
		data[index] = elem

	override function remove(int index)
		for i = index to usedSlots - 2
			data[i] = data[i + 1]
		usedSlots--

	override function getIndex(T elem) returns int
		for i = 0 to usedSlots - 1
			if data[i] == elem
				return i
		return 0

/* Generic ArrayList data class with fixed specific array size */
class ArrayListSize8<T> extends ArrayListBase implements IArrayList<T>
	private let size = 8
	private T array[size] data

	override function getSize() returns int
		return size

	override function getUsedSlots() returns int
		return usedSlots

	override function getElem(int index) returns T
		checkSlot(index, size)
		return data[index]

	override function setElem(int index, T elem)
		checkSlot(index, size)
		data[index] = elem

	override function add(T elem)
		usedSlots++
		data[usedSlots] = elem

	override function add(int index, T elem)
		usedSlots++
		for i = usedSlots - 1 downto index + 1
			data[i] = data[i - 1]
		data[index] = elem

	override function remove(int index)
		for i = index to usedSlots - 2
			data[i] = data[i + 1]
		usedSlots--

	override function getIndex(T elem) returns int
		for i = 0 to usedSlots - 1
			if data[i] == elem
				return i
		return 0

/* Generic ArrayList data class with fixed specific array size */
class ArrayListSize16<T> extends ArrayListBase implements IArrayList<T>
	private let size = 16
	private T array[size] data

	override function getSize() returns int
		return size

	override function getUsedSlots() returns int
		return usedSlots

	override function getElem(int index) returns T
		checkSlot(index, size)
		return data[index]

	override function setElem(int index, T elem)
		checkSlot(index, size)
		data[index] = elem

	override function add(T elem)
		usedSlots++
		data[usedSlots] = elem

	override function add(int index, T elem)
		usedSlots++
		for i = usedSlots - 1 downto index + 1
			data[i] = data[i - 1]
		data[index] = elem

	override function remove(int index)
		for i = index to usedSlots - 2
			data[i] = data[i + 1]
		usedSlots--

	override function getIndex(T elem) returns int
		for i = 0 to usedSlots - 1
			if data[i] == elem
				return i
		return 0
		
/** A generic list based on dynamically sized arrays. */
public class ArrayList<T>
	private let minPossibleSize = 2
	private let maxPossibleSize = 16
	private constant int minSize
	private IArrayList<T> data

	construct()
		minSize = minPossibleSize
		data = createData(validizeSize(minSize))
	construct(int minSize)
		this.minSize = validizeSize(minSize)
		data = createData(this.minSize)

	ondestroy
		destroy data

	private function createData(int validatedSize) returns IArrayList<T>
		switch validatedSize
			case 2
				return new ArrayListSize2<T>()
			case 4
				return new ArrayListSize4<T>()
			case 8
				return new ArrayListSize8<T>()
			case 16
				return new ArrayListSize16<T>()
		return null

	private function validizeSize(int newSize) returns int
		// Check if newSize is between the general valid boundaries:
		if newSize <= 0
			Log.error("ERROR: Size of ArrayList has to be bigger than 0")
		else if newSize > maxPossibleSize
			Log.error("ERROR: Size of ArrayList can't be bigger than " + maxPossibleSize.toString())
		// Evaluate min valid size:
		var validatedSize = minPossibleSize
		while newSize > validatedSize
			validatedSize *= 2
		return validatedSize

	private function resize(int newSize)
		var validatedSize = validizeSize(newSize)
		// Restrict resizing to minSize:
		if validatedSize < minSize
			validatedSize = minSize
		// Check if resizing is necessary:
		if validatedSize == data.getSize()
			return
		// Check if resizing is valid:
		if validatedSize < data.getUsedSlots()
			Log.error("ERROR: Can't resize ArrayList to " + validatedSize.toString() + " because it is smaller than the used slots " + data.getUsedSlots().toString())
		// Create new data with copied elements:
		let newData = createData(validatedSize)
		for i = 0 to data.getUsedSlots()
			newData.add(data.getElem(i))
		// Replace old data:
		destroy data
		data = newData
	
	/** Get the size of the list */	
	function size() returns int
		return data.getUsedSlots()

	/** Return whether the list is empty */
	function isEmpty() returns bool
		return data.getUsedSlots() == 0
		
	/** Return whether the element exists in the list */
	function has(T elem) returns bool
		return data.getIndex(elem) != 0

	/** Set an existing element at the given position to a new value */
	function set(int index, T elem)
		data.setElem(index, elem)

	/** Get the element at the given index from this list */
	function get(int index) returns T
		return data.getElem(index)

	/** Get the first element from this list */
	function getFirst() returns T
		if isEmpty()
			return null
		return data.getElem(0)
		
	/** Get the last element from this list */
	function getLast() returns T
		if isEmpty()
			return null
		return data.getElem(data.getUsedSlots())
		
	/** Equal to getLast function (available for compability) */
	function peek() returns T
		return getLast()
		
	/** Add elements to the end of the list */
	function add(vararg T elems)
		var size = data.getSize()
		for elem in elems
			// Resize if used slots already occupy the current size:
			if data.getUsedSlots() >= size
				resize(size + 1)
				size = data.getSize()
			// Add new element:
			data.add(elem)
	/** Adds the given element directly at the given index shifting the following elements towards the back */
	function add(T elem, int index)
		// Resize if used slots already occupy the current array size:
		let size = data.getSize()
		if data.getUsedSlots() >= size
			resize(size + 1)
		// Add new element:
		data.add(index, elem)

	/** Remove the first occurence of the element from this list */
	function remove(T elem)
		remove(data.getIndex(elem))
	/** Remove the element at the given index */
	function remove(int index)
		// Remove target element:
		data.remove(index)
		// Resize if used slots now would fit into array of smaller validized size:
		let newUsedSlots = data.getUsedSlots()
		if validizeSize(newUsedSlots) < data.getSize()
			resize(newUsedSlots)

	/** Replaces the first occurence of 'whichElement' with 'newElement' */
	function replace(T whichElement, T newElement) returns boolean
		let index = data.getIndex(whichElement)
		if index == 0
			return false
		data.setElem(index, newElement)
		return true
			
	/** Remove all elements from this list without destroying it */
	function clear()
		destroy data
		data = createData(minPossibleSize)

	/** Get an iterator for this list */
	function iterator() returns ALIterator<T>
		return new ALIterator(this)	
				
/** Iterator class for ArrayList. */
public class ALIterator<T>
	protected int i = 0
	protected ArrayList<T> list

	construct(ArrayList<T> list)
		this.list = list
		
	function hasNext() returns boolean
		return i < list.size()
		
	function lookahead() returns T
		T retVal = null
		if hasNext()
			retVal = list.get(i)
		return retVal
		
	function next() returns T
		i++
		return list.get(i - 1)

	function close()
		destroy this

		
// --------------------
// Test code
// --------------------
 
@test function testCreate()
	ArrayList<int> a = new ArrayList<int>(4)
	a.size().assertEquals(4)
	a.add(5)
	a.getLast().assertEquals(5)
	var b = new ArrayList<int>(3)
	b.size().assertEquals(4)
	b.add(7)
	b.getLast().assertEquals(7)
	b.getLast().assertEquals(6)  // TEST: should be wrong (check for testing functionality)
	
@test function testAddAndGet()
	var a = new ArrayList<int>(1)
	a.add(5)
	if a.get(1) != 5
		testFail("a")
	a.add(8)
	if a.get(2) != 8
		testFail("b")
	a.add(7)
	if a.get(3) != 7
		testFail("c")