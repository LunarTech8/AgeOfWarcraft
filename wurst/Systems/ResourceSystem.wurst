/*-------------------------------------------------------------
// Version number:
1.01

// Description:
Gives predefined unit types resources wares that can be extracted by workers via the harvest ability.

// Changelog:
- 1.01:
Initial version.
-------------------------------------------------------------*/
package ResourceSystem
import OnUnitEnterLeave
import ConstantDataSystem
import MultiboardPrioritySystem
import UtilityFunctions
import Stock
import StorageSystem
import UnitMap
import UnitIndexer
import ArrayList
import UnitTest


// --------------------
// Data code
// --------------------

let MAX_AUTO_ORDER_RANGE = 1024.

function getDefaultInitWares(int resourceUnitId) returns ArrayList<ware>
	var wares = new ArrayList<ware>(1)
	switch resourceUnitId
		case UnitIdsCustom.beech
			wares.add(ware(WareType.WOOD, GetRandomInt(6, 8)))
		case UnitIdsCustom.birch
			wares.add(ware(WareType.WOOD, GetRandomInt(4, 6)))
		case UnitIdsCustom.greyOak
			wares.add(ware(WareType.WOOD, GetRandomInt(6, 8)))
		case UnitIdsCustom.chestnut
			wares.add(ware(WareType.WOOD, GetRandomInt(4, 6)))
	return wares

function isKilledWhenDepleted(int resourceUnitId) returns bool
	switch resourceUnitId
		case UnitIdsCustom.beech
			return true
		case UnitIdsCustom.birch
			return true
		case UnitIdsCustom.greyOak
			return true
		case UnitIdsCustom.chestnut
			return true
		default
			return false

function getWorkProgressPerHarvest(int workerUnitId, int resourceUnitId) returns real
	switch resourceUnitId
		case UnitIdsCustom.beech
			switch workerUnitId
				case UnitIdsCustom.peasant
					return 0.67
			return 0.5
		case UnitIdsCustom.birch
			return 0.5
		case UnitIdsCustom.greyOak
			return 0.5
		case UnitIdsCustom.chestnut
			return 0.5
		default
			return 0.

function getWaresPerFinishedWork(int resourceUnitId) returns ArrayList<ware>
	var wares = new ArrayList<ware>(1)
	switch resourceUnitId
		case UnitIdsCustom.beech
			wares.add(ware(WareType.WOOD, 1))
		case UnitIdsCustom.birch
			wares.add(ware(WareType.WOOD, 1))
		case UnitIdsCustom.greyOak
			wares.add(ware(WareType.WOOD, 1))
		case UnitIdsCustom.chestnut
			wares.add(ware(WareType.WOOD, 1))
	return wares

/** Returns the harvest priority of given resource unit type. Higher values mean a higher priority. */
function getHarvestPriority(int resourceUnitId) returns int
	switch resourceUnitId
		case UnitIdsCustom.beech
			return 2
		case UnitIdsCustom.birch
			return 1
		case UnitIdsCustom.greyOak
			return 3
		case UnitIdsCustom.chestnut
			return 2
	return 0

/** Returns the maximum concurrent amount of workers allowed for of given resource unit type. */
function getMaxWorkerCount(int resourceUnitId) returns int
	switch resourceUnitId
		case UnitIdsCustom.beech
			return 2
		case UnitIdsCustom.birch
			return 1
		case UnitIdsCustom.greyOak
			return 3
		case UnitIdsCustom.chestnut
			return 2
	return 99


// --------------------
// Functional code
// --------------------

let RESOURCE_MAP = new UnitHashMap<Resource>()

class Resource extends Stock
	private bool isKilledWhenDepleted
	private real workProgress
	private int workerCount

	construct(unit resource, bool isKilledWhenDepleted, ArrayList<ware> initWares)
		super(initWares)
		user = resource
		this.isKilledWhenDepleted = isKilledWhenDepleted
		workProgress = 0.
		workerCount = 0

	private function work(real workProgress) returns bool
		this.workProgress += workProgress
		if this.workProgress >= 1.
			this.workProgress -= 1.
			return true
		else
			return false

	function getFreeWorkerSlots() returns int
		// testDebug(useTestName("Resource_getFreeWorkerSlots"), "Free slots for: " + (getMaxWorkerCount(user.getUnitId()) - workerCount).toString())
		return getMaxWorkerCount(user.getUnitId()) - workerCount

	/** Perform harvest and returns the harvested wares. */
	function harvest(int workerUnitId) returns ArrayList<ware>
		let resourceUnitId = user.getUnitId()
		// Work resource:
		if work(getWorkProgressPerHarvest(workerUnitId, resourceUnitId))
			// Return harvested wares:
			return getWaresPerFinishedWork(resourceUnitId)
		// No wares harvested yet:
		return null

	function addWorker() returns bool
		if workerCount < getMaxWorkerCount(user.getUnitId())
			workerCount += 1
			// testDebug(useTestName("Resource_addWorker"), "Added worker: " + workerCount.toString())
			return true
		else
			testDebug(useTestName("Resource_addWorker"), "Can't add worker: " + workerCount.toString())
			return false

	function removeWorker()
		if workerCount <= 0
			Log.error("ERROR: can not remove more workers from resource (" + GetUnitName(user) + ")")
		workerCount -= 1
		// testDebug(useTestName("Resource_removeWorker"), "Removed worker: " + workerCount.toString())

	function checkForDepletionKill() returns bool
		if isKilledWhenDepleted and wares.isEmpty()
			return true
		return false


function unit.addResource()
	if RESOURCE_MAP.has(this) == false
		var unitType = this.getUnitId()
		var wares = getDefaultInitWares(unitType)
		if wares.isEmpty()
			destroy wares
		else
			var resource = new Resource(this, isKilledWhenDepleted(unitType), wares)
			RESOURCE_MAP.put(this, resource)

function unit.removeResource()
	let resource = RESOURCE_MAP.tryRemove(this)
	if resource != null
		destroy resource

var findNextResource_Priority = 0
/** Returns next valid resource unit for the unit. */
public function unit.findNextResource() returns unit
	// Check if worker has enough free space:
	if this.getStorage().getFreeCapacity() > 0
		findNextResource_Priority = 0
		var filter = Filter() ->
			var conditionsFulfilled = false
			let filterUnit = GetFilterUnit()
			let resource = filterUnit.getResource()
			let priority = getHarvestPriority(filterUnit.getUnitId())
			// Only allow resources that have wares left, free worker slots and a high enough priority:
			if resource != null and resource.hasWares() and resource.getFreeWorkerSlots() > 0 and priority >= findNextResource_Priority
				findNextResource_Priority = priority
				conditionsFulfilled = true
			return conditionsFulfilled
		let target = this.getPos().getNearestUnit(MAX_AUTO_ORDER_RANGE, filter)
		filter.destr()
		return target
	else
		return null

/** Returns the resource of given unit. */
public function unit.getResource() returns Resource
	return RESOURCE_MAP.tryGet(this)

/** Returns the count of all resources. */
public function getResourceCount() returns int
	return RESOURCE_MAP.getValueCount()

/** Sets system relevant infos for given object in target multiboard. */
public function multiboard.setObjectInfoMultiboard(Resource r) returns bool
	this.addMultiboardLine("Resource:", HEADLINE_ICON_PATH)
	for i = 0 to (r.getAmountOfWareTypes() - 1)
		var ware = r.getWare(i)
		this.addMultiboardLine(ware.count.toString() + " " + ware.toString(true), ware.getIconPath())
	return true

init
	// Add resource to every appropriate new unit:
	onEnter() ->
		getEnterLeaveUnit().addResource()
	// Remove resource from every appropriate removed unit:
	onUnitDeindex() ->
		getIndexingUnit().removeResource()